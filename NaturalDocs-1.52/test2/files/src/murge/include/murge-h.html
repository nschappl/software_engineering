<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Murge</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css"><script language=JavaScript src="../../../../javascript/main.js"></script><script language=JavaScript src="../../../../javascript/prettify.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad();prettyPrint();"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.52 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->




<div id=Content><div class="CSection"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="Murge"></a>Murge</h1><div class=CBody><p>Murge is close to the Merge.</p><h4 class=CHeading>Description</h4><p>Murge is a common interface definition to multiple solver.</p><p>It has been initiated by <b>HIPS</b> and <b>PaStiX</b> solvers developpers in january 2009.</p><h4 class=CHeading>Integers</h4><p>Depending of your compilation options, <b>INTS</b> and <b>INTL</b> can be 32 or 64 bits.</p><p>In C user will be abble to use <b>INTS</b> types.&nbsp;  In Fortran user will have to use the correct type, corresponding to the compilation options.</p><p>If user doesn&rsquo;t define any compilation option, <b>INTS</b> and <b>INTL</b> will both be int.</p><p>If user defines <b>-DINTSIZE32</b>, <b>INTS</b> and <b>INTL</b> will both be 32 bits integers.</p><p>If user defines <b>-DINTSIZE64</b>, <b>INTS</b> will be 32 bits integers whereas <b>INTL</b> will be INT64 integers.</p><p>If user defines <b>-DINTSSIZE64</b>, both <b>INTS</b> and <b>INTL</b> will be 64 bit integers.</p><p>We recommand not to use <b>-DINTSSIZE64</b>, as <b>INTS</b> integers are supposed to keep being small integers, and there is no need to make them longs.</p><h4 class=CHeading>Coefficients</h4><p>The coefficients of the matrices and vectors is of type <b>COEF</b>.</p><p><b>COEF</b> can be simple or double precision and real or complex depending on compilation options.</p><p>If user defines nothing, <b>COEF</b> will be real simple precision.</p><p>If user defines <b>-DPREC_DOUBLE</b>, <b>COEF</b> will be double precision.</p><p>Defining nothing or <b>-DPREC_SIMPLE</b> will result in setting <b>COEF</b> precision to simple.</p><p>If user defines <b>-DTYPE_COMPLEX</b>, <b>COEF</b> will be complex, otherwise, if user defines nothing or <b>-DTYPE_REAL</b> it will be REAL.</p><h4 class=CHeading>Floating parameters</h4><p>Floating parameters are of type <b>REAL</b> which can be simple or double precision.</p><p>As for Coefficients, <b>REAL</b> precision also depends on <b>-DPREC_DOUBLE</b> compilation option.</p><p>Defining nothing or <b>-DPREC_SIMPLE</b> will result in setting <b>REAL</b> precision to simple.</p><h4 class=CHeading>Nodes and Unknowns</h4><p>In murge exists node and unknown, a node correspond to a node in the physical problem, which can be composed of multiple degrees of freedom.</p><p>Thus, the number of unknowns correspond to the number of node times the degree of freedom.</p><h4 class=CHeading>Authors</h4><p>HIPS and PaStiX developpers teams :</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Mathieu Faverge</td><td class=CDLDescription><a href="#" onClick="location.href='mai' + 'lto:' + 'fav' + 'erge' + '@' + 'labr' + 'i.fr'; return false;" class=LEMail>fav<span style="display: none">.nosp@m.</span>erge<span>@</span>labr<span style="display: none">.nosp@m.</span>i.fr</a></td></tr><tr><td class=CDLEntry>Jérémie Gaidamour</td><td class=CDLDescription><a href="#" onClick="location.href='mai' + 'lto:' + 'gaid' + 'amou' + '@' + 'labr' + 'i.fr'; return false;" class=LEMail>gaid<span style="display: none">.nosp@m.</span>amou<span>@</span>labr<span style="display: none">.nosp@m.</span>i.fr</a></td></tr><tr><td class=CDLEntry>Pascal  Hénon</td><td class=CDLDescription><a href="#" onClick="location.href='mai' + 'lto:' + 'he' + 'non' + '@' + 'labr' + 'i.fr'; return false;" class=LEMail>he<span style="display: none">.nosp@m.</span>non<span>@</span>labr<span style="display: none">.nosp@m.</span>i.fr</a></td></tr><tr><td class=CDLEntry>Xavier  Lacoste</td><td class=CDLDescription><a href="#" onClick="location.href='mai' + 'lto:' + 'lac' + 'oste' + '@' + 'labr' + 'i.fr'; return false;" class=LEMail>lac<span style="display: none">.nosp@m.</span>oste<span>@</span>labr<span style="display: none">.nosp@m.</span>i.fr</a></td></tr><tr><td class=CDLEntry>Pierre  Ramet</td><td class=CDLDescription><a href="#" onClick="location.href='mai' + 'lto:' + 'ra' + 'met' + '@' + 'labr' + 'i.fr'; return false;" class=LEMail>ra<span style="display: none">.nosp@m.</span>met<span>@</span>labr<span style="display: none">.nosp@m.</span>i.fr</a></td></tr></table><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SMain"><td class=SEntry><a href="#Murge" >Murge</a></td><td class=SDescription>Murge is close to the Merge.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Solver_setup_functions" >Solver setup functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_Initialize" id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">MURGE_Initialize</a></td><td class=SDescription>Allocate the instance arrays which will keeps intern data for all solver instances.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_SetDefaultOptions" id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a></td><td class=SDescription>Sets default options, for solver instance number <b>id</b>.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_SetOptionINT" id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">MURGE_SetOptionINT</a></td><td class=SDescription>Sets integer option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_SetOptionREAL" id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">MURGE_SetOptionREAL</a></td><td class=SDescription>Sets real option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_SetCommunicator" id=link5 onMouseOver="ShowTip(event, 'tt5', 'link5')" onMouseOut="HideTip('tt5')">MURGE_SetCommunicator</a></td><td class=SDescription>Sets MPI communicator for the given solver instance.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Graph_setup_function" >Graph setup function</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GraphBegin" id=link6 onMouseOver="ShowTip(event, 'tt6', 'link6')" onMouseOut="HideTip('tt6')">MURGE_GraphBegin</a></td><td class=SDescription>Begin building the adjency graph for renumbering and all preprocessing.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GraphEdge" id=link7 onMouseOver="ShowTip(event, 'tt7', 'link7')" onMouseOut="HideTip('tt7')">MURGE_GraphEdge</a></td><td class=SDescription>Adds an edge to the graph user is currently building.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GraphEnd" id=link8 onMouseOver="ShowTip(event, 'tt8', 'link8')" onMouseOut="HideTip('tt8')">MURGE_GraphEnd</a></td><td class=SDescription>End the graph building.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GraphGlobalCSR" id=link9 onMouseOver="ShowTip(event, 'tt9', 'link9')" onMouseOut="HideTip('tt9')">MURGE_GraphGlobalCSR</a></td><td class=SDescription>Build an adjency graph from a Compress Sparse Row matrix pattern.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GraphGlobalCSC" id=link10 onMouseOver="ShowTip(event, 'tt10', 'link10')" onMouseOut="HideTip('tt10')">MURGE_GraphGlobalCSC</a></td><td class=SDescription>Build an adjency graph from a Compress Sparse Column matrix pattern.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GraphGlobalIJV" id=link11 onMouseOver="ShowTip(event, 'tt11', 'link11')" onMouseOut="HideTip('tt11')">MURGE_GraphGlobalIJV</a></td><td class=SDescription>Build an adjency graph from a Compress Sparse Column matrix pattern.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#IO_functions" >IO functions</a></td><td class=SDescription>Allows to save and load solver state after preprocessing.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_Save" id=link12 onMouseOver="ShowTip(event, 'tt12', 'link12')" onMouseOut="HideTip('tt12')">MURGE_Save</a></td><td class=SDescription>Runs preprocessing step, if not done yet, and save the result to disk, into <b>directory</b>, so that it can be resume using <a href="#MURGE_Load" class=LFunction id=link13 onMouseOver="ShowTip(event, 'tt13', 'link13')" onMouseOut="HideTip('tt13')">MURGE_Load</a>.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_Load" id=link14 onMouseOver="ShowTip(event, 'tt13', 'link14')" onMouseOut="HideTip('tt13')">MURGE_Load</a></td><td class=SDescription>Loads preprocessing result from disk, into <b>directory</b>, where it had been saved by <a href="#MURGE_Save" class=LFunction id=link15 onMouseOver="ShowTip(event, 'tt12', 'link15')" onMouseOut="HideTip('tt12')">MURGE_Save</a>.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Getting_new_distribution" >Getting new distribution</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetLocalNodeNbr" id=link16 onMouseOver="ShowTip(event, 'tt14', 'link16')" onMouseOut="HideTip('tt14')">MURGE_GetLocalNodeNbr</a></td><td class=SDescription>Computes preprocessing step, if not done, and the number of Nodes in the new ditribution of the matrix.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GetLocalNodeList" id=link17 onMouseOver="ShowTip(event, 'tt15', 'link17')" onMouseOut="HideTip('tt15')">MURGE_GetLocalNodeList</a></td><td class=SDescription>Computes the local node list, corresponding to the new distribution, after preprocessing.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetLocalUnknownNbr" id=link18 onMouseOver="ShowTip(event, 'tt16', 'link18')" onMouseOut="HideTip('tt16')">MURGE_GetLocalUnknownNbr</a></td><td class=SDescription>Computes preprocessing step, if not done, and the number of Unkowns in the new ditribution of the matrix.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GetLocalUnknownList" id=link19 onMouseOver="ShowTip(event, 'tt17', 'link19')" onMouseOut="HideTip('tt17')">MURGE_GetLocalUnknownList</a></td><td class=SDescription>Computes the local unkown list, corresponding to the new distribution, after preprocessing.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Filling_the_matrix" >Filling the matrix</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_AssemblyBegin" id=link20 onMouseOver="ShowTip(event, 'tt18', 'link20')" onMouseOut="HideTip('tt18')">MURGE_AssemblyBegin</a></td><td class=SDescription>Begin Filling up sequence for the matrix, will allocate temporary structures used to build the matrix.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_AssemblySetValue" id=link21 onMouseOver="ShowTip(event, 'tt19', 'link21')" onMouseOut="HideTip('tt19')">MURGE_AssemblySetValue</a></td><td class=SDescription>Set a coefficient value in the matrix.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_AssemblySetNodeValues" id=link22 onMouseOver="ShowTip(event, 'tt20', 'link22')" onMouseOut="HideTip('tt20')">MURGE_AssemblySetNodeValues</a></td><td class=SDescription>Set coefficients value for a node in the matrix.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_AssemblySetBlockValues" id=link23 onMouseOver="ShowTip(event, 'tt21', 'link23')" onMouseOut="HideTip('tt21')">MURGE_AssemblySetBlockValues</a></td><td class=SDescription>Set coefficients value for a dens block in the matrix.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_AssemblyEnd" id=link24 onMouseOver="ShowTip(event, 'tt22', 'link24')" onMouseOut="HideTip('tt22')">MURGE_AssemblyEnd</a></td><td class=SDescription>End Filling up sequence for the matrix.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_MatrixReset" id=link25 onMouseOver="ShowTip(event, 'tt23', 'link25')" onMouseOut="HideTip('tt23')">MURGE_MatrixReset</a></td><td class=SDescription>Reset the matrix structure.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_MatrixGlobalCSR" id=link26 onMouseOver="ShowTip(event, 'tt24', 'link26')" onMouseOut="HideTip('tt24')">MURGE_MatrixGlobalCSR</a></td><td class=SDescription>Add the given global Compress Sparse Row matrix to the matrix.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_MatrixGlobalCSC" id=link27 onMouseOver="ShowTip(event, 'tt25', 'link27')" onMouseOut="HideTip('tt25')">MURGE_MatrixGlobalCSC</a></td><td class=SDescription>Add the given global Compress Sparse Column matrix to the matrix.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_MatrixGlobalIJV" id=link28 onMouseOver="ShowTip(event, 'tt26', 'link28')" onMouseOut="HideTip('tt26')">MURGE_MatrixGlobalIJV</a></td><td class=SDescription>Add the given global Compress Sparse Column matrix to the matrix.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Filling_the_right-hand-side_member" >Filling the right-hand-side member</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_SetGlobalRHS" id=link29 onMouseOver="ShowTip(event, 'tt27', 'link29')" onMouseOut="HideTip('tt27')">MURGE_SetGlobalRHS</a></td><td class=SDescription>Set the right-hand-side member in global mode.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_SetLocalRHS" id=link30 onMouseOver="ShowTip(event, 'tt28', 'link30')" onMouseOut="HideTip('tt28')">MURGE_SetLocalRHS</a></td><td class=SDescription>Set the right-hand-side member in local mode.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_SetRHS" id=link31 onMouseOver="ShowTip(event, 'tt29', 'link31')" onMouseOut="HideTip('tt29')">MURGE_SetRHS</a></td><td class=SDescription>Set the right-hand-side member, giving the list of coefficient that we set.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_RHSReset" id=link32 onMouseOver="ShowTip(event, 'tt30', 'link32')" onMouseOut="HideTip('tt30')">MURGE_RHSReset</a></td><td class=SDescription>Reset the right-hand-side.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Getting_the_solution" >Getting the solution</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetGlobalSolution" id=link33 onMouseOver="ShowTip(event, 'tt31', 'link33')" onMouseOut="HideTip('tt31')">MURGE_GetGlobalSolution</a></td><td class=SDescription>Perform Factorization and Solve, if needed, and then fill the global solution in <b>x</b>.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GetLocalSolution" id=link34 onMouseOver="ShowTip(event, 'tt32', 'link34')" onMouseOut="HideTip('tt32')">MURGE_GetLocalSolution</a></td><td class=SDescription>Perform Factorization and Solve, if needed, and then fill the local solution in <b>x</b>.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetSolution" id=link35 onMouseOver="ShowTip(event, 'tt33', 'link35')" onMouseOut="HideTip('tt33')">MURGE_GetSolution</a></td><td class=SDescription>Perform Factorization and Solve, if needed, and then fill the solution in <b>x</b> followin the given index list.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Scaling" >Scaling</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetGlobalNorm" id=link36 onMouseOver="ShowTip(event, 'tt34', 'link36')" onMouseOut="HideTip('tt34')">MURGE_GetGlobalNorm</a></td><td class=SDescription>Compute the global norm array following a norm rule.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GetLocalNorm" id=link37 onMouseOver="ShowTip(event, 'tt35', 'link37')" onMouseOut="HideTip('tt35')">MURGE_GetLocalNorm</a></td><td class=SDescription>Compute the local norm array following a norm rule.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetNorm" id=link38 onMouseOver="ShowTip(event, 'tt36', 'link38')" onMouseOut="HideTip('tt36')">MURGE_GetNorm</a></td><td class=SDescription>Compute the indicated part of the norm array following a norm rule.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_ApplyGlobalScaling" id=link39 onMouseOver="ShowTip(event, 'tt37', 'link39')" onMouseOut="HideTip('tt37')">MURGE_ApplyGlobalScaling</a></td><td class=SDescription>Apply scaling to local unknowns.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_ApplyLocalScaling" id=link40 onMouseOver="ShowTip(event, 'tt38', 'link40')" onMouseOut="HideTip('tt38')">MURGE_ApplyLocalScaling</a></td><td class=SDescription>Apply the local scaling array on the matrix.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_ApplyScaling" id=link41 onMouseOver="ShowTip(event, 'tt39', 'link41')" onMouseOut="HideTip('tt39')">MURGE_ApplyScaling</a></td><td class=SDescription>Apply the scaling array on the indicated part of the matrix</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Cleaning_up_this_mess" >Cleaning up this mess</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_Clean" id=link42 onMouseOver="ShowTip(event, 'tt40', 'link42')" onMouseOut="HideTip('tt40')">MURGE_Clean</a></td><td class=SDescription>Clean the given instance of the solver structure&rsquo;s.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_Finalize" id=link43 onMouseOver="ShowTip(event, 'tt41', 'link43')" onMouseOut="HideTip('tt41')">MURGE_Finalize</a></td><td class=SDescription>Clean all not cleaned instances and instances ID array.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetSolver" id=link44 onMouseOver="ShowTip(event, 'tt42', 'link44')" onMouseOut="HideTip('tt42')">MURGE_GetSolver</a></td><td class=SDescription>Return the solver ID Murge was compiled with.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Getting_Murge's_metrics" >Getting Murge&rsquo;s metrics</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetMetricINT" >MURGE_GetMetricINT</a></td><td class=SDescription>Get an integer metric from MURGE.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GetInfoREAL" id=link45 onMouseOver="ShowTip(event, 'tt43', 'link45')" onMouseOut="HideTip('tt43')">MURGE_GetInfoREAL</a></td><td class=SDescription>Get a real metric value from MURGE.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_PrintError" id=link46 onMouseOver="ShowTip(event, 'tt44', 'link46')" onMouseOut="HideTip('tt44')">MURGE_PrintError</a></td><td class=SDescription>Print the error message corresponding to ierror Parameters: error_number  - Error identification number.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_ExitOnError" id=link47 onMouseOver="ShowTip(event, 'tt45', 'link47')" onMouseOut="HideTip('tt45')">MURGE_ExitOnError</a></td><td class=SDescription>Print the error message corresponding to ierror. </td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Murge's_constants" >Murge&rsquo;s constants</a></td><td class=SDescription></td></tr><tr class="SEnumeration SIndent2 SMarked"><td class=SEntry><a href="#MURGE_RETURNS" >MURGE_RETURNS</a></td><td class=SDescription>Murge error return values.</td></tr><tr class="SEnumeration SIndent2"><td class=SEntry><a href="#MURGE_IPARAM" >MURGE_IPARAM</a></td><td class=SDescription>Murge integer parameters identifiers.</td></tr><tr class="SEnumeration SIndent2 SMarked"><td class=SEntry><a href="#MURGE_RPARAM" >MURGE_RPARAM</a></td><td class=SDescription>Murge real parameters identifiers.</td></tr><tr class="SEnumeration SIndent2"><td class=SEntry><a href="#MURGE_IINFO" >MURGE_IINFO</a></td><td class=SDescription>Murge integer metrics identifiers.</td></tr><tr class="SEnumeration SIndent2 SMarked"><td class=SEntry><a href="#MURGE_RINFO" >MURGE_RINFO</a></td><td class=SDescription>Murge real metrics identifiers.</td></tr><tr class="SEnumeration SIndent2"><td class=SEntry><a href="#MURGE_ASSEMBLY_MODE" >MURGE_ASSEMBLY_MODE</a></td><td class=SDescription>Indicates if user can ensure that the information he is giving respects the solver distribution.</td></tr><tr class="SEnumeration SIndent2 SMarked"><td class=SEntry><a href="#MURGE_ASSEMBLY_OP" >MURGE_ASSEMBLY_OP</a></td><td class=SDescription>Operations possible when a coefficient appear twice.</td></tr><tr class="SEnumeration SIndent2"><td class=SEntry><a href="#MURGE_SOLVER" >MURGE_SOLVER</a></td><td class=SDescription>Solver ID for murge compliant solvers.</td></tr><tr class="SEnumeration SIndent2 SMarked"><td class=SEntry><a href="#MURGE_BOOLEAN" >MURGE_BOOLEAN</a></td><td class=SDescription>Boolean for murge parameters</td></tr><tr class="SEnumeration SIndent2"><td class=SEntry><a href="#MURGE_NORM_RULES" >MURGE_NORM_RULES</a></td><td class=SDescription>Flags for Murge&rsquo;s norm rules</td></tr><tr class="SEnumeration SIndent2 SMarked"><td class=SEntry><a href="#MURGE_SCAL_MODES" >MURGE_SCAL_MODES</a></td><td class=SDescription>Flags for Murge&rsquo;s scaling rules</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Solver_setup_functions"></a>Solver setup functions</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_Initialize"></a>MURGE_Initialize</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Initialize(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>idnbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Allocate the instance arrays which will keeps intern data for all solver instances.</p><p>If user is creating several threads calling the solver, this function has to be called before creating threads to insure that the execution is thread safe.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>idnbr</td><td class=CDLDescription>Maximum number of solver instances that will be launched.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ALLOCATE</td><td class=CDLDescription>If for some reason, allocation was not successfull.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_INITIALIZE(IDNBR, IERROR)
  INTS, INTENT(IN)  :: IDNBR
  INTS, INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_INITIALIZE</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetDefaultOptions"></a>MURGE_SetDefaultOptions</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetDefaultOptions(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>stratnum</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Sets default options, for solver instance number <b>id</b>.</p><p>The default option set correspond to <b>stratnum</b> strategy ID, depending on the solver.</p><p>Needs <a href="#MURGE_Initialize" class=LFunction id=link48 onMouseOver="ShowTip(event, 'tt1', 'link48')" onMouseOut="HideTip('tt1')">MURGE_Initialize</a> to be called before to allocate solver instances array.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>stratnum</td><td class=CDLDescription>Strategy for the default option Set.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_Initialize" class=LFunction id=link49 onMouseOver="ShowTip(event, 'tt1', 'link49')" onMouseOut="HideTip('tt1')">MURGE_Initialize</a> was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>stratnum</b> is not valid.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ALLOCATE</td><td class=CDLDescription>If couldn&rsquo;t create solver instance.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_SETDEFAULTOPTIONS(ID, STRATNUM, IERROR)
  INTS, INTENT(IN)  :: ID, STRATNUM
  INTS, INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_SETDEFAULTOPTIONS</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetOptionINT"></a>MURGE_SetOptionINT</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetOptionINT(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>number,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Sets integer option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</p><p>Needs <a href="#MURGE_SetDefaultOptions" class=LFunction id=link50 onMouseOver="ShowTip(event, 'tt2', 'link50')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> to be called before to initiate solver instance data.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>number</td><td class=CDLDescription>Identification of the integer parameter.</td></tr><tr><td class=CDLEntry>value</td><td class=CDLDescription>value to set the parameter to.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_SetDefaultOptions" class=LFunction id=link51 onMouseOver="ShowTip(event, 'tt2', 'link51')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>number</b> or <b>value</b> are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_SETOPTIONINT(ID, NUMBER, VALUE, IERROR)
  INTS, INTENT(IN)    :: ID, NUMBER, VALUE
  INTS, INTENT(OUT)   :: IERROR
END SUBROUTINE MURGE_SETOPTIONINT</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetOptionREAL"></a>MURGE_SetOptionREAL</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetOptionREAL(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>number,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Sets real option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</p><p>Needs <a href="#MURGE_SetDefaultOptions" class=LFunction id=link52 onMouseOver="ShowTip(event, 'tt2', 'link52')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> to be called before to initiate solver instance data.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>number</td><td class=CDLDescription>Identification of the integer parameter.</td></tr><tr><td class=CDLEntry>value</td><td class=CDLDescription>value to set the parameter to.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_SetDefaultOptions" class=LFunction id=link53 onMouseOver="ShowTip(event, 'tt2', 'link53')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>number</b> or <b>value</b> are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_SETOPTIONREAL(ID, NUMBER, VALUE, IERROR)
  INTS, INTENT(IN)    :: ID, NUMBER
  REAL, INTENT(IN)    :: VALUE
  INTS, INTENT(OUT)   :: IERROR
END SUBROUTINE MURGE_SETOPTIONREAL</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetCommunicator"></a>MURGE_SetCommunicator</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetCommunicator(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>MPI_Comm&nbsp;</td><td class="PParameter  prettyprint " nowrap>mpicom</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Sets MPI communicator for the given solver instance.</p><p>Needs <a href="#MURGE_SetDefaultOptions" class=LFunction id=link54 onMouseOver="ShowTip(event, 'tt2', 'link54')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> to be called before to initiate solver instance data.</p><p>Musn&rsquo;t be called before &lt;MURGE_SAVE&gt;, &lt;MURGE_LOAD&gt;, <a href="#MURGE_GetLocalNodeNbr" class=LFunction id=link55 onMouseOver="ShowTip(event, 'tt14', 'link55')" onMouseOut="HideTip('tt14')">MURGE_GetLocalNodeNbr</a> nor <a href="#MURGE_GetLocalUnknownNbr" class=LFunction id=link56 onMouseOver="ShowTip(event, 'tt16', 'link56')" onMouseOut="HideTip('tt16')">MURGE_GetLocalUnknownNbr</a> because the solver as to be runned with the same MPI communicator all along.</p><p>If this function is not called, MPI communicator will be <b>MPI_COMM_WORLD</b>.</p><p>This function may not exist if the solver has been compiled without MPI.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>mpicomm</td><td class=CDLDescription>MPI communicator to affect the solver to.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_SetDefaultOptions" class=LFunction id=link57 onMouseOver="ShowTip(event, 'tt2', 'link57')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> was not called before or if it is called after the solver starts its computing tasks.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_SETCOMMUNICATOR(ID, MPICOMM, IERROR)
  INTS,            INTENT(IN)  :: ID
  INTEGER,         INTENT(IN)  :: MPICOMM
  INTS,            INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_SETCOMMUNICATOR</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Graph_setup_function"></a>Graph setup function</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphBegin"></a>MURGE_GraphBegin</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphBegin(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameter  prettyprint " nowrap>edgenbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Begin building the adjency graph for renumbering and all preprocessing.</p><p>Needs <a href="#MURGE_SetDefaultOptions" class=LFunction id=link58 onMouseOver="ShowTip(event, 'tt2', 'link58')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> to be called before to initiate solver instance data.</p><p>Allocate temporary structures needed to build the graph.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Global number of nodes in the graph.</td></tr><tr><td class=CDLEntry>edgenbr</td><td class=CDLDescription>Number of edges which will be added in the graph by proc.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_SetDefaultOptions" class=LFunction id=link59 onMouseOver="ShowTip(event, 'tt2', 'link59')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ALLOCATE</td><td class=CDLDescription>If Allocate didn&rsquo;t worked.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>N</b> or <b>edgenbr</b> are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GRAPHBEGIN(ID, N, EDGENBR, IERROR)
  INTS,      INTENT(IN)  :: ID, N
  INTL,      INTENT(IN)  :: EDGENBR
  INTS,      INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GRAPHBEGIN</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphEdge"></a>MURGE_GraphEdge</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphEdge(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>COL,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>ROW</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Adds an edge to the graph user is currently building.</p><p>Needs <a href="#MURGE_GraphBegin" class=LFunction id=link60 onMouseOver="ShowTip(event, 'tt6', 'link60')" onMouseOut="HideTip('tt6')">MURGE_GraphBegin</a> to be called before to initiate building sequence.</p><p>This function depends on integer parameter <b>MURGE_BASEVAL</b>.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>ROW</td><td class=CDLDescription>First vertex of the edge.</td></tr><tr><td class=CDLEntry>COL</td><td class=CDLDescription>Second vertex of the edge.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_GraphBegin" class=LFunction id=link61 onMouseOver="ShowTip(event, 'tt6', 'link61')" onMouseOut="HideTip('tt6')">MURGE_GraphBegin</a> was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>I</b> or <b>J</b> are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GRAPHEDGE(ID, ROW, COL, IERROR)
  INTS,      INTENT(IN)  :: ID, ROW, COL
  INTS,      INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GRAPHEDGE</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphEnd"></a>MURGE_GraphEnd</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphEnd(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>End the graph building.</p><p>Needs <a href="#MURGE_GraphBegin" class=LFunction id=link62 onMouseOver="ShowTip(event, 'tt6', 'link62')" onMouseOut="HideTip('tt6')">MURGE_GraphBegin</a> to be called before.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_GraphBegin" class=LFunction id=link63 onMouseOver="ShowTip(event, 'tt6', 'link63')" onMouseOut="HideTip('tt6')">MURGE_GraphBegin</a> was not called before or there are missing edges.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GRAPHEND(ID, IERROR)
  INTS,      INTENT(IN)  :: ID
  INTS,      INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GRAPHEND</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphGlobalCSR"></a>MURGE_GraphGlobalCSR</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalCSR(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>rowptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Build an adjency graph from a Compress Sparse Row matrix pattern.</p><p>Needs <a href="#MURGE_SetDefaultOptions" class=LFunction id=link64 onMouseOver="ShowTip(event, 'tt2', 'link64')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> to be called before.</p><p>This function depends on integer parameter <b>MURGE_BASEVAL</b>.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Global number of columns</td></tr><tr><td class=CDLEntry>rowptr</td><td class=CDLDescription>Index of the first element of each row in <b>COLS</b> array.</td></tr><tr><td class=CDLEntry>COLS</td><td class=CDLDescription>Global column numbers array.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Root processor : this processor enter the global data (-1 for all processors).</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_SetDefaultOptions" class=LFunction id=link65 onMouseOver="ShowTip(event, 'tt2', 'link65')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or CSR is not correct.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GRAPHGLOBALCSR(ID, N, ROWPTR, COLS, ROOT, IERROR)
  INTS, DIMENSION(0), INTENT(IN)  :: ID, N, ROOT
  INTL, DIMENSION(0), INTENT(IN)  :: ROWPTR
  INTS, DIMENSION(0), INTENT(IN)  :: COLS
  INTS, DIMENSION(0), INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GRAPHGLOBALCSR</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphGlobalCSC"></a>MURGE_GraphGlobalCSC</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalCSC(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>colptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Build an adjency graph from a Compress Sparse Column matrix pattern.</p><p>Needs <a href="#MURGE_SetDefaultOptions" class=LFunction id=link66 onMouseOver="ShowTip(event, 'tt2', 'link66')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> to be called before.</p><p>This function depends on integer parameter <b>MURGE_BASEVAL</b>.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Global number of columns</td></tr><tr><td class=CDLEntry>COLPTR</td><td class=CDLDescription>Index of the first element of each column in <b>ROWS</b> array.</td></tr><tr><td class=CDLEntry>ROWS</td><td class=CDLDescription>Global row number array.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Root processor : this processor enter the global data (-1 for all processors).</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_SetDefaultOptions" class=LFunction id=link67 onMouseOver="ShowTip(event, 'tt2', 'link67')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or CSC is not correct.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GRAPHGLOBALCSC(ID, N, COLPTR, ROWS, ROOT, IERROR)
  INTS,               INTENT(IN)  :: ID, N, ROOT
  INTL, DIMENSION(0), INTENT(IN)  :: COLPTR
  INTL, DIMENSION(0), INTENT(IN)  :: ROWS
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GRAPHGLOBALCSC</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphGlobalIJV"></a>MURGE_GraphGlobalIJV</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalIJV(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>NNZ,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROW,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COL,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Build an adjency graph from a Compress Sparse Column matrix pattern.</p><p>Needs <a href="#MURGE_SetDefaultOptions" class=LFunction id=link68 onMouseOver="ShowTip(event, 'tt2', 'link68')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> to be called before.</p><p>This function depends on integer parameter <b>MURGE_BASEVAL</b>.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Global number of unknowns.</td></tr><tr><td class=CDLEntry>NNZ</td><td class=CDLDescription>Global number of non zeros.</td></tr><tr><td class=CDLEntry>ROW</td><td class=CDLDescription>Global column number array. edges.</td></tr><tr><td class=CDLEntry>COL</td><td class=CDLDescription>Global row number array.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Root processor : this processor enter the global data (-1 for all processors).</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_SetDefaultOptions" class=LFunction id=link69 onMouseOver="ShowTip(event, 'tt2', 'link69')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or graph IJ is not correct.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GRAPHGLOBALIJV(ID, N, NNZ, ROW, COL, ROOT, IERROR)
  INTS,               INTENT(IN)  :: ID, N, ROOT
  INTL,               INTENT(IN)  :: NNZ
  INTS, DIMENSION(0), INTENT(IN)  :: ROW
  INTS, DIMENSION(0), INTENT(IN)  :: COL
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GRAPHGLOBALIJV</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="IO_functions"></a>IO functions</h3><div class=CBody><p>Allows to save and load solver state after preprocessing.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_Save"></a>MURGE_Save</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Save(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>directory</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Runs preprocessing step, if not done yet, and save the result to disk, into <b>directory</b>, so that it can be resume using <a href="#MURGE_Load" class=LFunction id=link70 onMouseOver="ShowTip(event, 'tt13', 'link70')" onMouseOut="HideTip('tt13')">MURGE_Load</a>.</p><p>Needs the graph to be built.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>directory</td><td class=CDLDescription>Path to the directory where to save the solver step.</td></tr></table><p>In Fortran, <b>STR_LEN</b> is the length of the string directory.</p><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If graph hasn&rsquo;t been built.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_IO</td><td class=CDLDescription>If file(s) couldn&rsquo;t be writen.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_SAVE(ID, DIRECTORY, STR_LEN, IERROR)
  INTS,             INTENT(IN)  :: ID, STR_LEN
  CHARACTER(len=*), INTENT(IN)  :: DIRECTORY
  INTS,             INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_SAVE</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_Load"></a>MURGE_Load</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Load(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>directory</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Loads preprocessing result from disk, into <b>directory</b>, where it had been saved by <a href="#MURGE_Save" class=LFunction id=link71 onMouseOver="ShowTip(event, 'tt12', 'link71')" onMouseOut="HideTip('tt12')">MURGE_Save</a>.</p><p>If preprocessing data was already computed or loaded, it will be overwriten.</p><p>Needs <a href="#MURGE_SetDefaultOptions" class=LFunction id=link72 onMouseOver="ShowTip(event, 'tt2', 'link72')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> to be called before to initiate solver instance data.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>directory</td><td class=CDLDescription>Path to the directory where to load the solver preprocessing data.</td></tr></table><p>In Fortran, <b>STR_LEN</b> is the length of the string directory.</p><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_SetDefaultOptions" class=LFunction id=link73 onMouseOver="ShowTip(event, 'tt2', 'link73')" onMouseOut="HideTip('tt2')">MURGE_SetDefaultOptions</a> was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_IO</td><td class=CDLDescription>If file(s) couldn&rsquo;t be read.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_LOAD(ID, DIRECTORY, STR_LEN, IERROR)
  INTS,             INTENT(IN)  :: ID, STR_LEN
  CHARACTER(len=*), INTENT(IN)  :: DIRECTORY
  INTS,             INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_LOAD</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Getting_new_distribution"></a>Getting new distribution</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalNodeNbr"></a>MURGE_GetLocalNodeNbr</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNodeNbr(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>nodenbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Computes preprocessing step, if not done, and the number of Nodes in the new ditribution of the matrix.</p><p>Needs the graph to be built.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>nodenbr</td><td class=CDLDescription><b>INTS</b> where to store number of nodes.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If graph hasn&rsquo;t been built.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>nodenbr</b> is <b>NULL</b> (can occur in C).</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETLOCALNODENBR(ID, NODENBR, IERROR)
  INTS, INTENT(IN)  :: ID
  INTS, INTENT(OUT) :: NODENBR
  INTS, INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETLOCALNODENBR</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalNodeList"></a>MURGE_GetLocalNodeList</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNodeList(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>nodelist</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Computes the local node list, corresponding to the new distribution, after preprocessing.</p><p><b>nodelist</b> array has to be allocated before calling this function.</p><p>As it&rsquo;s result determines the size of <b>nodelist</b> array, <a href="#MURGE_GetLocalNodeNbr" class=LFunction id=link74 onMouseOver="ShowTip(event, 'tt14', 'link74')" onMouseOut="HideTip('tt14')">MURGE_GetLocalNodeNbr</a> should be run before it.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>nodelist</td><td class=CDLDescription>Array where to store the list of local nodes.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>if <a href="#MURGE_GetLocalNodeNbr" class=LFunction id=link75 onMouseOver="ShowTip(event, 'tt14', 'link75')" onMouseOut="HideTip('tt14')">MURGE_GetLocalNodeNbr</a> has not been called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>nodelist</b> is <b>NULL</b> (can occur in C).</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETLOCALNODELIST(ID, NODELIST, IERROR)
  INTS,               INTENT(IN)  :: ID
  ! Warning : 0 is not the size of the array.
  ! Writing DIMENSION(:) does not work with
  ! the C function call (fortran send the array size?)
  INTS, DIMENSION(0), INTENT(OUT) :: NODELIST
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETLOCALNODELIST</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalUnknownNbr"></a>MURGE_GetLocalUnknownNbr</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalUnknownNbr(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>unkownnbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Computes preprocessing step, if not done, and the number of Unkowns in the new ditribution of the matrix.</p><p>Needs the graph to be built.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>unkownnbr</td><td class=CDLDescription><b>INTS</b> where to store number of unkowns.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If graph hasn&rsquo;t been built.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>unkownnbr</b> is <b>NULL</b> (can occur in C).</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETLOCALUNKOWNNBR(ID, UNKOWNNBR, IERROR)
  INTS, INTENT(IN)  :: ID
  INTS, INTENT(OUT) :: UNKOWNNBR
  INTS, INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETLOCALUNKOWNNBR</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalUnknownList"></a>MURGE_GetLocalUnknownList</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalUnknownList(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>unkownlist</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Computes the local unkown list, corresponding to the new distribution, after preprocessing.</p><p><b>unkownlist</b> array has to be allocated before calling this function.</p><p>As it&rsquo;s result determines the size of <b>unkownlist</b> array, <a href="../../sopalin/src/murge-c.html#MURGE_GetLocalUnkownNbr" class=LFunction id=link76 onMouseOver="ShowTip(event, 'tt46', 'link76')" onMouseOut="HideTip('tt46')">MURGE_GetLocalUnkownNbr</a> should be run before it.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>unkownlist</td><td class=CDLDescription>Array where to store the list of local unkowns.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>if <a href="../../sopalin/src/murge-c.html#MURGE_GetLocalUnkownNbr" class=LFunction id=link77 onMouseOver="ShowTip(event, 'tt46', 'link77')" onMouseOut="HideTip('tt46')">MURGE_GetLocalUnkownNbr</a> has not been called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>unkownlist</b> is <b>NULL</b> (can occur in C).</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETLOCALUNKOWNLIST(ID, UNKOWNLIST, IERROR)
  INTS,               INTENT(IN)  :: ID
  INTS, DIMENSION(0), INTENT(OUT) :: UNKOWNLIST
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETLOCALUNKOWNLIST</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Filling_the_matrix"></a>Filling the matrix</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_AssemblyBegin"></a>MURGE_AssemblyBegin</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblyBegin(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameter  prettyprint " nowrap>coefnbr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>op2,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>mode,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Begin Filling up sequence for the matrix, will allocate temporary structures used to build the matrix.</p><p>It will perform preprocessing if it has not been done yet.</p><p>It needs graph to be built.</p><p>Several assembly sequences can be performed on the same matrix.</p><p><b>mode</b> shouldn&rsquo;t be <b>MURGE_ASSEMBLY_RESPECT</b> if neither <a href="#MURGE_GetLocalNodeList" class=LFunction id=link78 onMouseOver="ShowTip(event, 'tt15', 'link78')" onMouseOut="HideTip('tt15')">MURGE_GetLocalNodeList</a> nor <a href="#MURGE_GetLocalUnknownList" class=LFunction id=link79 onMouseOver="ShowTip(event, 'tt17', 'link79')" onMouseOut="HideTip('tt17')">MURGE_GetLocalUnknownList</a> has been called.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>coefnbr</td><td class=CDLDescription>Number of coeficients he will had.</td></tr><tr><td class=CDLEntry>op</td><td class=CDLDescription>Operation to perform for coefficient which appear several tim (see <a href="#MURGE_ASSEMBLY_OP" class=LType id=link80 onMouseOver="ShowTip(event, 'tt47', 'link80')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>op2</td><td class=CDLDescription>Operation to perform when a coefficient is set by two different processors (see <a href="#MURGE_ASSEMBLY_OP" class=LType id=link81 onMouseOver="ShowTip(event, 'tt47', 'link81')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>mode</td><td class=CDLDescription>Indicates if user ensure he will respect solvers distribution (see <a href="#MURGE_ASSEMBLY_MODE" class=LType id=link82 onMouseOver="ShowTip(event, 'tt48', 'link82')" onMouseOut="HideTip('tt48')">MURGE_ASSEMBLY_MODE</a>).</td></tr><tr><td class=CDLEntry>sym</td><td class=CDLDescription>Indicates if user will give coefficient in a symmetric way (ie: only triangullar part) or not.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If graph hasn&rsquo;t been built before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ALLOCATE</td><td class=CDLDescription>If Allocation didn&rsquo;t worked.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range, or <b>op</b>, <b>mode</b>, <b>sym</b>, or <b>coefnbr</b> are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_ASSEMBLYBEGIN(ID, COEFNBR, OP, OP2, MODE, SYM, IERROR)
  INTS,      INTENT(IN)  :: ID, OP, OP2, MODE, SYM
  INTL,      INTENT(IN)  :: COEFNBR
  INTS,      INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_ASSEMBLYBEGIN</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_AssemblySetValue"></a>MURGE_AssemblySetValue</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblySetValue(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>ROW,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>COL,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Set a coefficient value in the matrix.</p><p>Needs <a href="#MURGE_AssemblyBegin" class=LFunction id=link83 onMouseOver="ShowTip(event, 'tt18', 'link83')" onMouseOut="HideTip('tt18')">MURGE_AssemblyBegin</a> to be called before.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>ROW</td><td class=CDLDescription>Global row number of the coefficient.</td></tr><tr><td class=CDLEntry>COL</td><td class=CDLDescription>Global column number of the coefficient.</td></tr><tr><td class=CDLEntry>value</td><td class=CDLDescription>value of the coefficient.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If we are not in an assembly section.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range, or <b>ROW</b> or <b>COL</b> are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_ASSEMBLYSETVALUE(ID, ROW, COL, VALUE, IERROR)
  INTS,      INTENT(IN)  :: ID, ROW, COL
  COEF,      INTENT(IN)  :: VALUE
  INTS,      INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_ASSEMBLYSETVALUE</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_AssemblySetNodeValues"></a>MURGE_AssemblySetNodeValues</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblySetNodeValues(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>ROW,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>COL,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Set coefficients value for a node in the matrix.</p><p>Needs <a href="#MURGE_AssemblyBegin" class=LFunction id=link84 onMouseOver="ShowTip(event, 'tt18', 'link84')" onMouseOut="HideTip('tt18')">MURGE_AssemblyBegin</a> to be called before.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>ROW</td><td class=CDLDescription>Global row number of the coefficient.</td></tr><tr><td class=CDLEntry>COL</td><td class=CDLDescription>Global column number of the coefficient.</td></tr><tr><td class=CDLEntry>values</td><td class=CDLDescription>value of the coefficient.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If we are not in an assembly section.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range, or <b>ROW</b> or <b>COL</b> are not valid, or, in C, if <b>values</b> is NULL.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_ASSEMBLYSETNODEVALUES(ID, ROW, COL, VALUES, IERROR)
  INTS,               INTENT(IN)  :: ID, ROW, COL
  COEF, DIMENSION(0), INTENT(IN)  :: VALUES
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_ASSEMBLYSETNODEVALUES</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_AssemblySetBlockValues"></a>MURGE_AssemblySetBlockValues</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblySetBlockValues(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>nROW,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWlist,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>nCOL,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLlist,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Set coefficients value for a dens block in the matrix.</p><p>Needs <a href="#MURGE_AssemblyBegin" class=LFunction id=link85 onMouseOver="ShowTip(event, 'tt18', 'link85')" onMouseOut="HideTip('tt18')">MURGE_AssemblyBegin</a> to be called before.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>nROW</td><td class=CDLDescription>Number of rows in the dense matrix.</td></tr><tr><td class=CDLEntry>ROWlist</td><td class=CDLDescription>List of global row numbers.</td></tr><tr><td class=CDLEntry>nCOL</td><td class=CDLDescription>Number of columns in the dense matrix.</td></tr><tr><td class=CDLEntry>COLlist</td><td class=CDLDescription>List of global column numbers.</td></tr><tr><td class=CDLEntry>values</td><td class=CDLDescription>Values array, by column (Fortran style)</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If we are not in an assembly section.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range, or <b>nI</b> or <b>nJ</b> are not valid, or, in C, if <b>Ilist</b>, <b>Jlist</b> or <b>values</b> is NULL.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_ASSEMBLYSETBLOCKVALUES(ID, NROW, ROWLIST, &amp;
                                &amp; NCOL, COLLIST, VALUES, IERROR)
  INTS,               INTENT(IN)  :: ID, NROW, NCOL
  INTS, DIMENSION(0), INTENT(IN)  :: ROWLIST
  INTL, DIMENSION(0), INTENT(IN)  :: COLLIST
  COEF, DIMENSION(0), INTENT(IN)  :: VALUES
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_ASSEMBLYSETBLOCKVALUES</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_AssemblyEnd"></a>MURGE_AssemblyEnd</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblyEnd(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>End Filling up sequence for the matrix.</p><p>Needs <a href="#MURGE_AssemblyBegin" class=LFunction id=link86 onMouseOver="ShowTip(event, 'tt18', 'link86')" onMouseOut="HideTip('tt18')">MURGE_AssemblyBegin</a> to be called before.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If we are not in an assembly section.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_ASSEMBLYEND(ID, IERROR)
  INTS,      INTENT(IN)  :: ID
  INTS,      INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_ASSEMBLYEND</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_MatrixReset"></a>MURGE_MatrixReset</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixReset(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Reset the matrix structure.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_MATRIXRESET(ID, IERROR)
  INTS,      INTENT(IN)  :: ID
  INTS,      INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_MATRIXRESET</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_MatrixGlobalCSR"></a>MURGE_MatrixGlobalCSR</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixGlobalCSR(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>rowptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Add the given global Compress Sparse Row matrix to the matrix.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Number of columns.</td></tr><tr><td class=CDLEntry>rowptr</td><td class=CDLDescription>Index of the first element of each row in <b>COLS</b> and <b>values</b> array.</td></tr><tr><td class=CDLEntry>COLS</td><td class=CDLDescription>Column number array.</td></tr><tr><td class=CDLEntry>values</td><td class=CDLDescription>values array.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Root processor for MPI communications.</td></tr><tr><td class=CDLEntry>op</td><td class=CDLDescription>Operation to perform if a coefficient appear twice (see <a href="#MURGE_ASSEMBLY_OP" class=LType id=link87 onMouseOver="ShowTip(event, 'tt47', 'link87')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>sym</td><td class=CDLDescription>Indicates if user will give coefficient in a symmetric way (ie: only triangullar part) or not.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range, if <b>root</b>, <b>op</b> or the CSR are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_MATRIXGLOBALCSR(ID, N, ROWPTR, COLS, VALUES, &amp;
                               &amp; ROOT, OP, SYM,  IERROR)
  INTS,               INTENT(IN)  :: ID, N, ROOT, OP, SYM
  INTL, DIMENSION(0), INTENT(IN)  :: ROWPTR
  INTS, DIMENSION(0), INTENT(IN)  :: COLS
  COEF, DIMENSION(0), INTENT(IN)  :: VALUES
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_MATRIXGLOBALCSR</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_MatrixGlobalCSC"></a>MURGE_MatrixGlobalCSC</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixGlobalCSC(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLPTR,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Add the given global Compress Sparse Column matrix to the matrix.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Number of columns.</td></tr><tr><td class=CDLEntry>colptr</td><td class=CDLDescription>Index of the first element of each column in <b>ROWS</b> and <b>values</b> array.</td></tr><tr><td class=CDLEntry>ROWS</td><td class=CDLDescription>Row number array.</td></tr><tr><td class=CDLEntry>values</td><td class=CDLDescription>values array.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Root processor for MPI communications.</td></tr><tr><td class=CDLEntry>op</td><td class=CDLDescription>Operation to perform if a coefficient appear twice (see <a href="#MURGE_ASSEMBLY_OP" class=LType id=link88 onMouseOver="ShowTip(event, 'tt47', 'link88')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>sym</td><td class=CDLDescription>Indicates if user will give coefficient in a symmetric way (ie: only triangullar part) or not.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range, if <b>root</b>, <b>op</b> or the CSC are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_MATRIXGLOBALCSC(ID, N, COLPTR, ROWS, &amp;
                             &amp; VALUES, ROOT, OP, SYM, IERROR)
  INTS,               INTENT(IN)  :: ID, N, ROOT, OP, SYM
  INTL, DIMENSION(0), INTENT(IN)  :: COLPTR
  INTS, DIMENSION(0), INTENT(IN)  :: ROWS
  COEF, DIMENSION(0), INTENT(IN)  :: VALUES
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_MATRIXGLOBALCSC</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_MatrixGlobalIJV"></a>MURGE_MatrixGlobalIJV</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixGlobalIJV(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>NNZ,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Add the given global Compress Sparse Column matrix to the matrix.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Number of edges.</td></tr><tr><td class=CDLEntry>NNZ</td><td class=CDLDescription>Number of non zeros.</td></tr><tr><td class=CDLEntry>ROWS</td><td class=CDLDescription>Global row number array.</td></tr><tr><td class=CDLEntry>COLS</td><td class=CDLDescription>Global column number array.</td></tr><tr><td class=CDLEntry>values</td><td class=CDLDescription>values array.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Root processor for MPI communications.</td></tr><tr><td class=CDLEntry>op</td><td class=CDLDescription>Operation to perform if a coefficient appear twice (see <a href="#MURGE_ASSEMBLY_OP" class=LType id=link89 onMouseOver="ShowTip(event, 'tt47', 'link89')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>sym</td><td class=CDLDescription>Indicates if user will give coefficient in a symmetric way (ie: only triangullar part) or not.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range, if <b>root</b>, <b>op</b>, <b>ROWS</b> or <b>COLS</b> are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_MATRIXGLOBALIJV(ID, N, NNZ, ROWS, COLS, VALUES, &amp;
                               &amp; ROOT, OP, SYM, IERROR)
  INTS,               INTENT(IN)  :: ID, ROOT, OP, SYM, N
  INTL,               INTENT(IN)  :: NNZ
  INTS, DIMENSION(0), INTENT(IN)  :: ROWS, COLS
  COEF, DIMENSION(0), INTENT(IN)  :: VALUES
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_MATRIXGLOBALIJV</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Filling_the_right-hand-side_member"></a>Filling the right-hand-side member</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetGlobalRHS"></a>MURGE_SetGlobalRHS</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetGlobalRHS(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>b,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Set the right-hand-side member in global mode.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>b</td><td class=CDLDescription>Array of size global column number which correspond to the right-hand-side member.</td></tr><tr><td class=CDLEntry>op</td><td class=CDLDescription>Operation to perform if a coefficient appear twice (see <a href="#MURGE_ASSEMBLY_OP" class=LType id=link90 onMouseOver="ShowTip(event, 'tt47', 'link90')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Indicates which processor has the right-hand-side member, -1 for all.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_SETGLOBALRHS(ID, B, OP, ROOT, IERROR)
  INTS,               INTENT(IN)  :: ID, OP, ROOT
  COEF, DIMENSION(0), INTENT(IN)  :: B
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_SETGLOBALRHS</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetLocalRHS"></a>MURGE_SetLocalRHS</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetLocalRHS(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>b,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op2</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Set the right-hand-side member in local mode.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>b</td><td class=CDLDescription>Array of size local column number which correspond to the right-hand-side member.</td></tr><tr><td class=CDLEntry>op</td><td class=CDLDescription>Operation to perform if a coefficient appear twice (see <a href="#MURGE_ASSEMBLY_OP" class=LType id=link91 onMouseOver="ShowTip(event, 'tt47', 'link91')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>op2</td><td class=CDLDescription>Operation to perform when a coefficient is set by two different processors (see <a href="#MURGE_ASSEMBLY_OP" class=LType id=link92 onMouseOver="ShowTip(event, 'tt47', 'link92')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_OP</a>).</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_SETLOCALRHS(ID, B, OP, OP2, IERROR)
  INTS,               INTENT(IN)  :: ID, OP, OP2
  COEF, DIMENSION(0), INTENT(IN)  :: B
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_SETLOCALRHS</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetRHS"></a>MURGE_SetRHS</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetRHS(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>b,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op2,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Set the right-hand-side member, giving the list of coefficient that we set.</p><p><b>mode</b> shouldn&rsquo;t be <b>MURGE_ASSEMBLY_RESPECT</b> if neither <a href="#MURGE_GetLocalNodeList" class=LFunction id=link93 onMouseOver="ShowTip(event, 'tt15', 'link93')" onMouseOut="HideTip('tt15')">MURGE_GetLocalNodeList</a> nor <a href="#MURGE_GetLocalUnknownList" class=LFunction id=link94 onMouseOver="ShowTip(event, 'tt17', 'link94')" onMouseOut="HideTip('tt17')">MURGE_GetLocalUnknownList</a> has been called.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>Number of coefficients to set.</td></tr><tr><td class=CDLEntry>coefsidx</td><td class=CDLDescription>List of global index of the coefficients to set.</td></tr><tr><td class=CDLEntry>B</td><td class=CDLDescription>Array of coefficients values.</td></tr><tr><td class=CDLEntry>op</td><td class=CDLDescription>Operation to perform if a coefficient appear twice (see <a href="#MURGE_ASSEMBLY_OP" class=LType id=link95 onMouseOver="ShowTip(event, 'tt47', 'link95')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>op2</td><td class=CDLDescription>Operation to perform when a coefficient is set by two different processors (see <a href="#MURGE_ASSEMBLY_OP" class=LType id=link96 onMouseOver="ShowTip(event, 'tt47', 'link96')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>mode</td><td class=CDLDescription>Indicates if user ensure he will respect solvers distribution (see <a href="#MURGE_ASSEMBLY_MODE" class=LType id=link97 onMouseOver="ShowTip(event, 'tt48', 'link97')" onMouseOut="HideTip('tt48')">MURGE_ASSEMBLY_MODE</a>).</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or if <b>mode</b> or <b>op</b> are not valid, or, in C, if <b>coeflist</b> or <b>b</b> are NULL.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_SETRHS(ID, N, COEFSIDX, B, OP, OP2, MODE, IERROR)
  INTS,               INTENT(IN)  :: ID, N, OP, OP2, MODE
  INTS, DIMENSION(0), INTENT(IN)  :: COEFSIDX
  COEF, DIMENSION(0), INTENT(IN)  :: B
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_SETRHS</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_RHSReset"></a>MURGE_RHSReset</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_RHSReset(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Reset the right-hand-side.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_RHSRESET(ID, IERROR)
  INTS,      INTENT(IN)  :: ID
  INTS,      INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_RHSRESET</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Getting_the_solution"></a>Getting the solution</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetGlobalSolution"></a>MURGE_GetGlobalSolution</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetGlobalSolution(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>x,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Perform Factorization and Solve, if needed, and then fill the global solution in <b>x</b>.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>x</td><td class=CDLDescription>Array of size global column number*dof which will contain the solution</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Indicates which processor will have the solution at the end of the call, -1 for all.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETGLOBALSOLUTION(ID, X, ROOT, IERROR)
  INTS,               INTENT(IN)  :: ID, ROOT
  COEF, DIMENSION(0), INTENT(OUT) :: X
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETGLOBALSOLUTION</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalSolution"></a>MURGE_GetLocalSolution</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalSolution(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>x</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Perform Factorization and Solve, if needed, and then fill the local solution in <b>x</b>.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>x</td><td class=CDLDescription>Array of size local column number*dof which will contain the solution</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETLOCALSOLUTION(ID, X, IERROR)
  INTS,               INTENT(IN)  :: ID
  COEF, DIMENSION(0), INTENT(OUT) :: X
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETLOCALSOLUTION</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetSolution"></a>MURGE_GetSolution</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetSolution(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>x,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Perform Factorization and Solve, if needed, and then fill the solution in <b>x</b> followin the given index list.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>Number of coefficients user wants to get.</td></tr><tr><td class=CDLEntry>coefsidx</td><td class=CDLDescription>List of the coefficients user wants to get.</td></tr><tr><td class=CDLEntry>x</td><td class=CDLDescription>Array of size dof*n which will contain the solution.</td></tr><tr><td class=CDLEntry>mode</td><td class=CDLDescription>Indicates if the user is sure to respect the distribution.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETSOLUTION(ID, N, COEFSIDX, X, MODE, IERROR)
  INTS,               INTENT(IN)  :: ID, MODE, N
  INTS, DIMENSION(0), INTENT(IN)  :: COEFSIDX
  COEF, DIMENSION(0), INTENT(OUT) :: X
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETSOLUTION</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Scaling"></a>Scaling</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetGlobalNorm"></a>MURGE_GetGlobalNorm</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetGlobalNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Compute the global norm array following a norm rule.</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>norm</td><td class=CDLDescription>Array of size global column number*dof which will contain the norm values</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Indicates which processor will have the norm array at the end of the call, -1 for all.</td></tr><tr><td class=CDLEntry>rule</td><td class=CDLDescription>Rule to follow to build norm array, see <a href="#MURGE_NORM_RULES" class=LType id=link98 onMouseOver="ShowTip(event, 'tt49', 'link98')" onMouseOut="HideTip('tt49')">MURGE_NORM_RULES</a></td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETGLOBALNORM(ID, NORM, ROOT, RULE, IERROR)
  INTS,               INTENT(IN)  :: ID, ROOT, RULE
  REAL, DIMENSION(0), INTENT(OUT) :: NORM
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETGLOBALNORM</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalNorm"></a>MURGE_GetLocalNorm</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Compute the local norm array following a norm rule.</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>norm</td><td class=CDLDescription>Array of size local column number*dof which will contain the solution</td></tr><tr><td class=CDLEntry>rule</td><td class=CDLDescription>Rule to follow to build norm array, see <a href="#MURGE_NORM_RULES" class=LType id=link99 onMouseOver="ShowTip(event, 'tt49', 'link99')" onMouseOut="HideTip('tt49')">MURGE_NORM_RULES</a></td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETLOCALNORM(ID, NORM, RULE, IERROR)
  INTS,               INTENT(IN)  :: ID, RULE
  REAL, DIMENSION(0), INTENT(OUT) :: NORM
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETLOCALNORM</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetNorm"></a>MURGE_GetNorm</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Compute the indicated part of the norm array following a norm rule.</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>Number of coefficients user wants to get norm of.</td></tr><tr><td class=CDLEntry>coefsidx</td><td class=CDLDescription>List of the coefficients user wants to get norm of.</td></tr><tr><td class=CDLEntry>norm</td><td class=CDLDescription>Array of size dof*n which will contain the solution.</td></tr><tr><td class=CDLEntry>rule</td><td class=CDLDescription>Rule to follow to build norm array, see <a href="#MURGE_NORM_RULES" class=LType id=link100 onMouseOver="ShowTip(event, 'tt49', 'link100')" onMouseOut="HideTip('tt49')">MURGE_NORM_RULES</a></td></tr><tr><td class=CDLEntry>mode</td><td class=CDLDescription>Indicates if the user is sure to respect the distribution.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETNORM(ID, N, COEFSIDX, NORM, RULE, MODE, IERROR)
  INTS,               INTENT(IN)  :: ID, MODE, N, RULE
  INTS, DIMENSION(0), INTENT(IN)  :: COEFSIDX
  COEF, DIMENSION(0), INTENT(OUT) :: NORM
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETNORM</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ApplyGlobalScaling"></a>MURGE_ApplyGlobalScaling</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyGlobalScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Apply scaling to local unknowns.</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>scal</td><td class=CDLDescription>Scaling user wants to apply.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Indicates which processor that posses the scaling array, -1 for all.</td></tr><tr><td class=CDLEntry>sc_mode</td><td class=CDLDescription>Indicate if the scaling is applied on rows or on columns.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_APPLYGLOBALSCALING(ID, SCAL, ROOT, SC_MODE, IERROR)
  INTS,               INTENT(IN)  :: ID, ROOT, SC_MODE
  REAL, DIMENSION(0), INTENT(OUT) :: SCAL
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_APPLYGLOBALSCALING</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ApplyLocalScaling"></a>MURGE_ApplyLocalScaling</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyLocalScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Apply the local scaling array on the matrix.</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>scal</td><td class=CDLDescription>Array of size local column number*dof which will contain the solution.</td></tr><tr><td class=CDLEntry>sc_mode</td><td class=CDLDescription>Indicate if the scaling is applied on rows or on columns.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_APPLYLOCALSCALING(ID, SCAL, SC_MODE, IERROR)
  INTS,               INTENT(IN)  :: ID, SC_MODE
  REAL, DIMENSION(0), INTENT(OUT) :: SCAL
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_APPLYLOCALSCALING</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ApplyScaling"></a>MURGE_ApplyScaling</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Apply the scaling array on the indicated part of the matrix</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>Number of coefficients user wants to scale.</td></tr><tr><td class=CDLEntry>coefsidx</td><td class=CDLDescription>List of the coefficients user wants to scale.</td></tr><tr><td class=CDLEntry>scal</td><td class=CDLDescription>Array of size dof*n which will contain the solution.</td></tr><tr><td class=CDLEntry>sc_mode</td><td class=CDLDescription>Indicate if the scaling is applied on rows or on columns.</td></tr><tr><td class=CDLEntry>mode</td><td class=CDLDescription>Indicates if the user is sure to respect the distribution.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_APPLYSCALING(ID, N, COEFSIDX, SCAL, SC_MODE, MODE, IERROR)
  INTS,               INTENT(IN)  :: ID, SC_MODE, MODE, N
  INTS, DIMENSION(0), INTENT(IN)  :: COEFSIDX
  COEF, DIMENSION(0), INTENT(OUT) :: SCAL
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_APPLYSCALING</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Cleaning_up_this_mess"></a>Cleaning up this mess</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_Clean"></a>MURGE_Clean</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Clean(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Clean the given instance of the solver structure&rsquo;s.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_CLEAN(ID, IERROR)
  INTS, INTENT(IN)  :: ID
  INTS, INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_CLEAN</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_Finalize"></a>MURGE_Finalize</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">INTS MURGE_Finalize()</td></tr></table></blockquote><p>Clean all not cleaned instances and instances ID array.</p><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_FINALIZE(IERROR)
  INTS, INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_FINALIZE</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetSolver"></a>MURGE_GetSolver</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetSolver(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>solver</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Return the solver ID Murge was compiled with.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>solver</td><td class=CDLDescription>Integer to store solver ID.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If execution ended normaly.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETSOLVER(SOLVER, IERROR)
  INTS,  INTENT(OUT) :: SOLVER
  INTS,  INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETSOLVER</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Getting_Murge's_metrics"></a>Getting Murge&rsquo;s metrics</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetMetricINT"></a>MURGE_GetMetricINT</h3><div class=CBody><p>Get an integer metric from MURGE.</p><p>See <a href="#MURGE_IINFO" class=LType id=link101 onMouseOver="ShowTip(event, 'tt50', 'link101')" onMouseOut="HideTip('tt50')">MURGE_IINFOS</a> and the solver documentation to get available metric list.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>metric</td><td class=CDLDescription>Wanted metric identification number.</td></tr><tr><td class=CDLEntry>value</td><td class=CDLDescription>Integer which will contain the value of the metric.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If execution ended normaly.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If metric is not available in the current solver state.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>metric</b> or <b>value</b> are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETINFOINT(ID, INFO, VALUE, IERROR)
 INTS, INTENT(IN)  :: ID, INFO
 INTL, INTENT(OUT) :: VALUE
 INTS, INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETINFOINT</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetInfoREAL"></a>MURGE_GetInfoREAL</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetInfoREAL(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>metric,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Get a real metric value from MURGE.</p><p>See <a href="#MURGE_RINFO" class=LType id=link102 onMouseOver="ShowTip(event, 'tt51', 'link102')" onMouseOut="HideTip('tt51')">MURGE_RINFOS</a> and the solver documentation to get available metric list.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>metric</td><td class=CDLDescription>Wanted metric identification number.</td></tr><tr><td class=CDLEntry>value</td><td class=CDLDescription>Real which will contain the value of the metric.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If execution ended normaly.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If metric is not available in the current solver state.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>metric</b> or <b>value</b> are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETINFOREAL(ID, INFO, VALUE, IERROR)
 INTS, INTENT(IN)  :: ID, INFO
 REAL, INTENT(OUT) :: VALUE
 INTS, INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETINFOREAL</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_PrintError"></a>MURGE_PrintError</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_PrintError(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>error_number</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Print the error message corresponding to ierror Parameters: error_number  - Error identification number.</p><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If ierror does not match an error number</td></tr><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_PRINTERROR(ERROR_NUMBER, IERROR)
  INTS, INTENT(IN)  :: IERROR
  INTS, INTENT(OUT) :: ERROR_NUMBER
END SUBROUTINE MURGE_PRINTERROR</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ExitOnError"></a>MURGE_ExitOnError</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ExitOnError(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>error_number</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Print the error message corresponding to ierror.&nbsp; If the ierr is not MURGE_SUCCESS then the program is stopped.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>ierror</td><td class=CDLDescription>Error identification number.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully; stop the program otherwise.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_EXITONERROR(ERROR_NUMBER, IERROR)
  INTS, INTENT(IN)  :: IERROR
  INTS, INTENT(OUT) :: ERROR_NUMBER
END SUBROUTINE MURGE_EXITONERROR</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Murge's_constants"></a>Murge&rsquo;s constants</h3></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_RETURNS"></a>MURGE_RETURNS</h3><div class=CBody><p>Murge error return values.</p><h4 class=CHeading>Contains</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_SUCCESS"></a>MURGE_SUCCESS</td><td class=CDLDescription>If function runs correctly.</td></tr><tr><td class=CDLEntry><a name="MURGE_ERR_ALLOCATE"></a>MURGE_ERR_ALLOCATE</td><td class=CDLDescription>If couldn&rsquo;t allocate.</td></tr><tr><td class=CDLEntry><a name="MURGE_ERR_IO"></a>MURGE_ERR_IO</td><td class=CDLDescription>If there was an input or output error.</td></tr><tr><td class=CDLEntry><a name="MURGE_ERR_PARAMETER"></a>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If one parameter is not correct.</td></tr><tr><td class=CDLEntry><a name="MURGE_ERR_ORDER"></a>MURGE_ERR_ORDER</td><td class=CDLDescription>If function were run in wrong order.</td></tr><tr><td class=CDLEntry><a name="MURGE_ERR_SOLVER"></a>MURGE_ERR_SOLVER</td><td class=CDLDescription>Internal solver error.</td></tr><tr><td class=CDLEntry><a name="MURGE_ERR_NOT_IMPLEMENTED"></a>MURGE_ERR_NOT_IMPLEMENTED</td><td class=CDLDescription>Not yet implemented.</td></tr></table></div></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_IPARAM"></a>MURGE_IPARAM</h3><div class=CBody><p>Murge integer parameters identifiers.</p><p>Solvers may implement is own list of parameters.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_IPARAM_BASEVAL"></a>MURGE_IPARAM_BASEVAL</td><td class=CDLDescription>Numbering style , 0 for C, 1 for fortran.</td></tr><tr><td class=CDLEntry><a name="MURGE_IPARAM_DOF"></a>MURGE_IPARAM_DOF</td><td class=CDLDescription>Number of degrees of freedom.</td></tr></table></div></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_RPARAM"></a>MURGE_RPARAM</h3><div class=CBody><p>Murge real parameters identifiers.</p><p>Solvers may implement is own list of parameters.</p><h4 class=CHeading>Contains</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_RPARAM_EPSILON_ERROR"></a>MURGE_RPARAM_EPSILON_ERROR</td><td class=CDLDescription>Wanted norm error at the end of solve.</td></tr></table></div></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_IINFO"></a>MURGE_IINFO</h3><div class=CBody><p>Murge integer metrics identifiers.</p><p>Solvers may implement is own list of parameters.</p><h4 class=CHeading>Contains</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_IINFOS_NNZ"></a>MURGE_IINFOS_NNZ</td><td class=CDLDescription>Number of non zeros in factorized matrix.</td></tr></table></div></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_RINFO"></a>MURGE_RINFO</h3><div class=CBody><p>Murge real metrics identifiers.</p><p>Solvers may implement is own list of parameters.</p><h4 class=CHeading>Contains</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_RINFO_FACT_TIME"></a>MURGE_RINFO_FACT_TIME</td><td class=CDLDescription>Factorization time.</td></tr><tr><td class=CDLEntry><a name="MURGE_RINFO_SOLVE_TIME"></a>MURGE_RINFO_SOLVE_TIME</td><td class=CDLDescription>Solving time.</td></tr></table></div></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_ASSEMBLY_MODE"></a>MURGE_ASSEMBLY_MODE</h3><div class=CBody><p>Indicates if user can ensure that the information he is giving respects the solver distribution.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_ASSEMBLY_RESPECT"></a>MURGE_ASSEMBLY_RESPECT</td><td class=CDLDescription>User ensure he respects distribution during assembly.&nbsp; See solver documentation.</td></tr><tr><td class=CDLEntry><a name="MURGE_ASSEMBLY_FOOL"></a>MURGE_ASSEMBLY_FOOL</td><td class=CDLDescription>User is not sure he will respect ditribution during assembly</td></tr></table></div></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_ASSEMBLY_OP"></a>MURGE_ASSEMBLY_OP</h3><div class=CBody><p>Operations possible when a coefficient appear twice.</p><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_ASSEMBLY_ADD"></a>MURGE_ASSEMBLY_ADD</td><td class=CDLDescription>Coefficients will be added during assembly.</td></tr><tr><td class=CDLEntry><a name="MURGE_ASSEMBLY_OVW"></a>MURGE_ASSEMBLY_OVW</td><td class=CDLDescription>Coefficients will be overwriten during assembly.</td></tr><tr><td class=CDLEntry><a name="MURGE_ASSEMBLY_MAX"></a>MURGE_ASSEMBLY_MAX</td><td class=CDLDescription>Maximum value will be used for assembly.</td></tr><tr><td class=CDLEntry><a name="MURGE_ASSEMBLY_MIN"></a>MURGE_ASSEMBLY_MIN</td><td class=CDLDescription>Minimum value will be used for assembly.</td></tr></table></div></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_SOLVER"></a>MURGE_SOLVER</h3><div class=CBody><p>Solver ID for murge compliant solvers.</p><h4 class=CHeading>Contains</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_SOLVER_HIPS"></a>MURGE_SOLVER_HIPS</td><td class=CDLDescription>HIPS hybrid solver.</td></tr><tr><td class=CDLEntry><a name="MURGE_SOLVER_PASTIX"></a>MURGE_SOLVER_PASTIX</td><td class=CDLDescription>PaStiX direct solver.</td></tr></table></div></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_BOOLEAN"></a>MURGE_BOOLEAN</h3><div class=CBody><p>Boolean for murge parameters</p><h4 class=CHeading>Contains</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_BOOLEAN_FALSE"></a>MURGE_BOOLEAN_FALSE</td><td class=CDLDescription>False value</td></tr><tr><td class=CDLEntry><a name="MURGE_BOOLEAN_TRUE"></a>MURGE_BOOLEAN_TRUE</td><td class=CDLDescription>True value</td></tr></table></div></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_NORM_RULES"></a>MURGE_NORM_RULES</h3><div class=CBody><p>Flags for Murge&rsquo;s norm rules</p><h4 class=CHeading>Contains</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_NORM_MAX_COL"></a>MURGE_NORM_MAX_COL</td><td class=CDLDescription>Get maximum column value  (absolute value).</td></tr><tr><td class=CDLEntry><a name="MURGE_NORM_MAX_ROW"></a>MURGE_NORM_MAX_ROW</td><td class=CDLDescription>Get maximum row value     (absolute value).</td></tr><tr><td class=CDLEntry><a name="MURGE_NORM_2_COL"></a>MURGE_NORM_2_COL</td><td class=CDLDescription>Get the norm 2 of columns.</td></tr><tr><td class=CDLEntry><a name="MURGE_NORM_2_ROW"></a>MURGE_NORM_2_ROW</td><td class=CDLDescription>Get the norm 2 of rows.</td></tr></table></div></div></div>

<div class="CEnumeration"><div class=CTopic><h3 class=CTitle><a name="MURGE_SCAL_MODES"></a>MURGE_SCAL_MODES</h3><div class=CBody><p>Flags for Murge&rsquo;s scaling rules</p><h4 class=CHeading>Contains</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="MURGE_SCAL_COL"></a>MURGE_SCAL_COL</td><td class=CDLDescription>Perform scaling on columns</td></tr><tr><td class=CDLEntry><a name="MURGE_SCAL_ROW"></a>MURGE_SCAL_ROW</td><td class=CDLDescription>Perform scaling on rows.</td></tr></table></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Initialize(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>idnbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Allocate the instance arrays which will keeps intern data for all solver instances.</div></div><div class=CToolTip id="tt2"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetDefaultOptions(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>stratnum</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Sets default options, for solver instance number <b>id</b>.</div></div><div class=CToolTip id="tt3"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetOptionINT(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>number,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Sets integer option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</div></div><div class=CToolTip id="tt4"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetOptionREAL(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>number,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Sets real option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</div></div><div class=CToolTip id="tt5"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetCommunicator(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>MPI_Comm&nbsp;</td><td class="PParameter  prettyprint " nowrap>mpicom</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Sets MPI communicator for the given solver instance.</div></div><div class=CToolTip id="tt6"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphBegin(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameter  prettyprint " nowrap>edgenbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Begin building the adjency graph for renumbering and all preprocessing.</div></div><div class=CToolTip id="tt7"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphEdge(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>COL,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>ROW</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Adds an edge to the graph user is currently building.</div></div><div class=CToolTip id="tt8"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphEnd(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>End the graph building.</div></div><div class=CToolTip id="tt9"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalCSR(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>rowptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Build an adjency graph from a Compress Sparse Row matrix pattern.</div></div><div class=CToolTip id="tt10"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalCSC(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>colptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Build an adjency graph from a Compress Sparse Column matrix pattern.</div></div><div class=CToolTip id="tt11"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalIJV(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>NNZ,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROW,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COL,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Build an adjency graph from a Compress Sparse Column matrix pattern.</div></div><div class=CToolTip id="tt12"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Save(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>directory</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Runs preprocessing step, if not done yet, and save the result to disk, into <b>directory</b>, so that it can be resume using MURGE_Load.</div></div><div class=CToolTip id="tt13"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Load(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>directory</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Loads preprocessing result from disk, into <b>directory</b>, where it had been saved by MURGE_Save.</div></div><div class=CToolTip id="tt14"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNodeNbr(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>nodenbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Computes preprocessing step, if not done, and the number of Nodes in the new ditribution of the matrix.</div></div><div class=CToolTip id="tt15"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNodeList(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>nodelist</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Computes the local node list, corresponding to the new distribution, after preprocessing.</div></div><div class=CToolTip id="tt16"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalUnknownNbr(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>unkownnbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Computes preprocessing step, if not done, and the number of Unkowns in the new ditribution of the matrix.</div></div><div class=CToolTip id="tt17"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalUnknownList(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>unkownlist</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Computes the local unkown list, corresponding to the new distribution, after preprocessing.</div></div><div class=CToolTip id="tt18"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblyBegin(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameter  prettyprint " nowrap>coefnbr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>op2,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>mode,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Begin Filling up sequence for the matrix, will allocate temporary structures used to build the matrix.</div></div><div class=CToolTip id="tt19"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblySetValue(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>ROW,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>COL,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Set a coefficient value in the matrix.</div></div><div class=CToolTip id="tt20"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblySetNodeValues(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>ROW,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>COL,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Set coefficients value for a node in the matrix.</div></div><div class=CToolTip id="tt21"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblySetBlockValues(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>nROW,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWlist,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>nCOL,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLlist,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Set coefficients value for a dens block in the matrix.</div></div><div class=CToolTip id="tt22"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblyEnd(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>End Filling up sequence for the matrix.</div></div><div class=CToolTip id="tt23"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixReset(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Reset the matrix structure.</div></div><div class=CToolTip id="tt24"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixGlobalCSR(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>rowptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Add the given global Compress Sparse Row matrix to the matrix.</div></div><div class=CToolTip id="tt25"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixGlobalCSC(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLPTR,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Add the given global Compress Sparse Column matrix to the matrix.</div></div><div class=CToolTip id="tt26"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixGlobalIJV(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>NNZ,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Add the given global Compress Sparse Column matrix to the matrix.</div></div><div class=CToolTip id="tt27"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetGlobalRHS(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>b,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Set the right-hand-side member in global mode.</div></div><div class=CToolTip id="tt28"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetLocalRHS(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>b,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op2</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Set the right-hand-side member in local mode.</div></div><div class=CToolTip id="tt29"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetRHS(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>b,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op2,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Set the right-hand-side member, giving the list of coefficient that we set.</div></div><div class=CToolTip id="tt30"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_RHSReset(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Reset the right-hand-side.</div></div><div class=CToolTip id="tt31"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetGlobalSolution(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>x,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Perform Factorization and Solve, if needed, and then fill the global solution in <b>x</b>.</div></div><div class=CToolTip id="tt32"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalSolution(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>x</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Perform Factorization and Solve, if needed, and then fill the local solution in <b>x</b>.</div></div><div class=CToolTip id="tt33"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetSolution(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>x,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Perform Factorization and Solve, if needed, and then fill the solution in <b>x</b> followin the given index list.</div></div><div class=CToolTip id="tt34"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetGlobalNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Compute the global norm array following a norm rule.</div></div><div class=CToolTip id="tt35"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Compute the local norm array following a norm rule.</div></div><div class=CToolTip id="tt36"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Compute the indicated part of the norm array following a norm rule.</div></div><div class=CToolTip id="tt37"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyGlobalScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Apply scaling to local unknowns.</div></div><div class=CToolTip id="tt38"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyLocalScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Apply the local scaling array on the matrix.</div></div><div class=CToolTip id="tt39"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Apply the scaling array on the indicated part of the matrix</div></div><div class=CToolTip id="tt40"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Clean(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Clean the given instance of the solver structure&rsquo;s.</div></div><div class=CToolTip id="tt41"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">INTS MURGE_Finalize()</td></tr></table></blockquote>Clean all not cleaned instances and instances ID array.</div></div><div class=CToolTip id="tt42"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetSolver(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>solver</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Return the solver ID Murge was compiled with.</div></div><div class=CToolTip id="tt43"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetInfoREAL(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>metric,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Get a real metric value from MURGE.</div></div><div class=CToolTip id="tt44"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_PrintError(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>error_number</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Print the error message corresponding to ierror Parameters: error_number  - Error identification number.</div></div><div class=CToolTip id="tt45"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ExitOnError(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>error_number</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Print the error message corresponding to ierror. </div></div><div class=CToolTip id="tt46"><div class=CFunction>Computes preprocessing step, if not done, and the number of Unkowns in the new ditribution of the matrix.</div></div><div class=CToolTip id="tt47"><div class=CType>Operations possible when a coefficient appear twice.</div></div><div class=CToolTip id="tt48"><div class=CType>Indicates if user can ensure that the information he is giving respects the solver distribution.</div></div><div class=CToolTip id="tt49"><div class=CType>Flags for Murge&rsquo;s norm rules</div></div><div class=CToolTip id="tt50"><div class=CType>Murge integer metrics identifiers.</div></div><div class=CToolTip id="tt51"><div class=CType>Murge real metrics identifiers.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>