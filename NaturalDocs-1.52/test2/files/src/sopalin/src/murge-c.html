<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>murge.c</title><link rel="stylesheet" type="text/css" href="../../../../styles/main.css"><script language=JavaScript src="../../../../javascript/main.js"></script><script language=JavaScript src="../../../../javascript/prettify.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad();prettyPrint();"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.52 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->




<div id=Content><div class="CFile"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="murge.c"></a>murge.c</h1><div class=CBody><p>This file implements <a href="../../murge/include/murge-h.html#Murge" class=LSection id=link45 onMouseOver="ShowTip(event, 'tt1', 'link45')" onMouseOut="HideTip('tt1')">Murge</a> interface.</p><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SMain"><td class=SEntry><a href="#murge.c" >murge.c</a></td><td class=SDescription>This file implements <a href="../../murge/include/murge-h.html#Murge" class=LSection id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">Murge</a> interface.</td></tr><tr class="SGeneric SMarked"><td class=SEntry><a href="#Authors" >Authors</a></td><td class=SDescription></td></tr><tr class="SSection"><td class=SEntry><a href="#Structures" >Structures</a></td><td class=SDescription></td></tr><tr class="SClass"><td class=SEntry><a href="#ijv_" id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">ijv_</a></td><td class=SDescription>Structure to represente coefficients.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#ijv_.Types" >Types</a></td><td class=SDescription></td></tr><tr class="SType SIndent2 SMarked"><td class=SEntry><a href="#ijv_.ijv_t" >ijv_t</a></td><td class=SDescription>Alias to structure <a href="#ijv_" class=LClass id=link3 onMouseOver="ShowTip(event, 'tt2', 'link3')" onMouseOut="HideTip('tt2')">ijv_</a>.</td></tr><tr class="SClass"><td class=SEntry><a href="#murge_data_t" >murge_data_t</a></td><td class=SDescription>Structure used to store murge data</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#murge_data_t.Types" >Types</a></td><td class=SDescription></td></tr><tr class="SType SIndent2 SMarked"><td class=SEntry><a href="#murge_data_t.murge_data_t" >murge_data_t</a></td><td class=SDescription>alias to structure &lt;murge_data_&gt;.</td></tr><tr class="SSection"><td class=SEntry><a href="#Global_variables" >Global variables</a></td><td class=SDescription></td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Variables" >Variables</a></td><td class=SDescription></td></tr><tr class="SVariable SIndent2 SMarked"><td class=SEntry><a href="#Global_variables" >Global variables</a></td><td class=SDescription></td></tr><tr class="SSection"><td class=SEntry><a href="#Functions" >Functions</a></td><td class=SDescription></td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Auxilary_functions" >Auxilary functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#check_preprocessing" id=link4 onMouseOver="ShowTip(event, 'tt3', 'link4')" onMouseOut="HideTip('tt3')">check_preprocessing</a></td><td class=SDescription>Checks if preprocessing (blend) has been called.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#cmp_ijv" id=link5 onMouseOver="ShowTip(event, 'tt4', 'link5')" onMouseOut="HideTip('tt4')">cmp_ijv</a></td><td class=SDescription>Compare to &lt;ijv_t&gt; structures on their column value (j) then, if equal, their row value (i).</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MurgeTmpijvOwnSort" id=link6 onMouseOver="ShowTip(event, 'tt5', 'link6')" onMouseOut="HideTip('tt5')">MurgeTmpijvOwnSort</a></td><td class=SDescription>Sort ijv_t structure, sorting also associated values. </td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MurgeTmpijvSort" id=link7 onMouseOver="ShowTip(event, 'tt6', 'link7')" onMouseOut="HideTip('tt6')">MurgeTmpijvSort</a></td><td class=SDescription>Sort ijv_t structure, sorting also associated values. </td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Solver_setup_functions" >Solver setup functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetSolver" id=link8 onMouseOver="ShowTip(event, 'tt7', 'link8')" onMouseOut="HideTip('tt7')">MURGE_GetSolver</a></td><td class=SDescription>returns MURGE_SOLVER_PASTIX</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_Initialize" id=link9 onMouseOver="ShowTip(event, 'tt8', 'link9')" onMouseOut="HideTip('tt8')">MURGE_Initialize</a></td><td class=SDescription>Allocate the instance arrays which will keeps intern data for all solver instances.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_SetDefaultOptions" id=link10 onMouseOver="ShowTip(event, 'tt9', 'link10')" onMouseOut="HideTip('tt9')">MURGE_SetDefaultOptions</a></td><td class=SDescription>Create a solver instance if not created yet.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_SetOptionINT" id=link11 onMouseOver="ShowTip(event, 'tt10', 'link11')" onMouseOut="HideTip('tt10')">MURGE_SetOptionINT</a></td><td class=SDescription>Sets integer option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_SetOptionREAL" id=link12 onMouseOver="ShowTip(event, 'tt11', 'link12')" onMouseOut="HideTip('tt11')">MURGE_SetOptionREAL</a></td><td class=SDescription>Sets real option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_SetCommunicator" id=link13 onMouseOver="ShowTip(event, 'tt12', 'link13')" onMouseOut="HideTip('tt12')">MURGE_SetCommunicator</a></td><td class=SDescription>Sets MPI communicator for the given solver instance.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#I/O_functions" >I/<wbr>O functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_Save" id=link14 onMouseOver="ShowTip(event, 'tt13', 'link14')" onMouseOut="HideTip('tt13')">MURGE_Save</a></td><td class=SDescription>Runs preprocessing step, if not done yet, and save the result to disk, into <b>directory</b>, so that it can be resume using <a href="#MURGE_Load" class=LFunction id=link15 onMouseOver="ShowTip(event, 'tt14', 'link15')" onMouseOut="HideTip('tt14')">MURGE_Load</a>.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_Load" id=link16 onMouseOver="ShowTip(event, 'tt14', 'link16')" onMouseOut="HideTip('tt14')">MURGE_Load</a></td><td class=SDescription>Loads preprocessing result from disk, into <b>directory</b>, where it had been saved by <a href="#MURGE_Save" class=LFunction id=link17 onMouseOver="ShowTip(event, 'tt13', 'link17')" onMouseOut="HideTip('tt13')">MURGE_Save</a>.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Getting_solver's_distribution" >Getting solver&rsquo;s distribution</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetLocalNodeNbr" id=link18 onMouseOver="ShowTip(event, 'tt15', 'link18')" onMouseOut="HideTip('tt15')">MURGE_GetLocalNodeNbr</a></td><td class=SDescription>Computes preprocessing step, if not done, and the number of Nodes in the new ditribution of the matrix.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GetLocalNodeList" id=link19 onMouseOver="ShowTip(event, 'tt16', 'link19')" onMouseOut="HideTip('tt16')">MURGE_GetLocalNodeList</a></td><td class=SDescription>Computes the local node list, corresponding to the new distribution, after preprocessing.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetLocalUnkownNbr" >MURGE_GetLocalUnkownNbr</a></td><td class=SDescription>Computes preprocessing step, if not done, and the number of Unkowns in the new ditribution of the matrix.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GetLocalUnkownList" >MURGE_GetLocalUnkownList</a></td><td class=SDescription>Computes the local unkown list, corresponding to the new distribution, after preprocessing.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Graph_setup_functions" >Graph setup functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GraphBegin" id=link20 onMouseOver="ShowTip(event, 'tt17', 'link20')" onMouseOut="HideTip('tt17')">MURGE_GraphBegin</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GraphEdge" id=link21 onMouseOver="ShowTip(event, 'tt18', 'link21')" onMouseOut="HideTip('tt18')">MURGE_GraphEdge</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GraphEnd" id=link22 onMouseOver="ShowTip(event, 'tt19', 'link22')" onMouseOut="HideTip('tt19')">MURGE_GraphEnd</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GraphGlobalCSR" id=link23 onMouseOver="ShowTip(event, 'tt20', 'link23')" onMouseOut="HideTip('tt20')">MURGE_GraphGlobalCSR</a></td><td class=SDescription>Enter the adjency graph in a Column Sparse Row form.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GraphGlobalCSC" id=link24 onMouseOver="ShowTip(event, 'tt21', 'link24')" onMouseOut="HideTip('tt21')">MURGE_GraphGlobalCSC</a></td><td class=SDescription>Distribute the CSC on the processors and use it for PaStiX calls.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GraphGlobalIJV" id=link25 onMouseOver="ShowTip(event, 'tt22', 'link25')" onMouseOut="HideTip('tt22')">MURGE_GraphGlobalIJV</a></td><td class=SDescription>Distribute the graph on the processors, compress the columns array and use the built CSCd to call PaStiX.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Matrix_assembly_functions" >Matrix assembly functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_AssemblyBegin" id=link26 onMouseOver="ShowTip(event, 'tt23', 'link26')" onMouseOut="HideTip('tt23')">MURGE_AssemblyBegin</a></td><td class=SDescription>Check that preprocessing has been performed, if not performs it.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_AssemblyEnd" id=link27 onMouseOver="ShowTip(event, 'tt24', 'link27')" onMouseOut="HideTip('tt24')">MURGE_AssemblyEnd</a></td><td class=SDescription>We have on each proc a part of the matrix in two structure, one containing nodes to add to the CSCd the other containing simple values.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_MatrixGlobalCSC" id=link28 onMouseOver="ShowTip(event, 'tt25', 'link28')" onMouseOut="HideTip('tt25')">MURGE_MatrixGlobalCSC</a></td><td class=SDescription>Give a CSC on one processor to PaStiX.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_MatrixGlobalIJV" id=link29 onMouseOver="ShowTip(event, 'tt26', 'link29')" onMouseOut="HideTip('tt26')">MURGE_MatrixGlobalIJV</a></td><td class=SDescription>Add the given global Compress Sparse Column matrix to the matrix.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Filling_the_right-hand-side_member" >Filling the right-hand-side member</a></td><td class=SDescription></td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Getting_the_solution" >Getting the solution</a></td><td class=SDescription></td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Cleaning_up_this_mess" >Cleaning up this mess</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_PrintError" id=link30 onMouseOver="ShowTip(event, 'tt27', 'link30')" onMouseOut="HideTip('tt27')">MURGE_PrintError</a></td><td class=SDescription>Print the error message corresponding to ierror Parameters: error_number  - Error identification number.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_ExitOnError" id=link31 onMouseOver="ShowTip(event, 'tt28', 'link31')" onMouseOut="HideTip('tt28')">MURGE_ExitOnError</a></td><td class=SDescription>Print the error message corresponding to ierror. </td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Scaling" >Scaling</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetGlobalNorm" id=link32 onMouseOver="ShowTip(event, 'tt29', 'link32')" onMouseOut="HideTip('tt29')">MURGE_GetGlobalNorm</a></td><td class=SDescription>Compute the global norm array following a norm rule.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GetLocalNorm" id=link33 onMouseOver="ShowTip(event, 'tt30', 'link33')" onMouseOut="HideTip('tt30')">MURGE_GetLocalNorm</a></td><td class=SDescription>Compute the local norm array following a norm rule.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetNorm" id=link34 onMouseOver="ShowTip(event, 'tt31', 'link34')" onMouseOut="HideTip('tt31')">MURGE_GetNorm</a></td><td class=SDescription>Compute the indicated part of the norm array following a norm rule.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_ApplyGlobalScaling" id=link35 onMouseOver="ShowTip(event, 'tt32', 'link35')" onMouseOut="HideTip('tt32')">MURGE_ApplyGlobalScaling</a></td><td class=SDescription>Apply scaling to local unknowns.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_ApplyLocalScaling" id=link36 onMouseOver="ShowTip(event, 'tt33', 'link36')" onMouseOut="HideTip('tt33')">MURGE_ApplyLocalScaling</a></td><td class=SDescription>Apply the local scaling array on the matrix.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_ApplyScaling" id=link37 onMouseOver="ShowTip(event, 'tt34', 'link37')" onMouseOut="HideTip('tt34')">MURGE_ApplyScaling</a></td><td class=SDescription>Apply the scaling array on the indicated part of the matrix</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#Specific_PaStiX_functions" >Specific PaStiX functions.</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_Analyze" id=link38 onMouseOver="ShowTip(event, 'tt35', 'link38')" onMouseOut="HideTip('tt35')">MURGE_Analyze</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_Factorize" id=link39 onMouseOver="ShowTip(event, 'tt36', 'link39')" onMouseOut="HideTip('tt36')">MURGE_Factorize</a></td><td class=SDescription>Perform matrix factorization.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_ForceNoFacto" id=link40 onMouseOver="ShowTip(event, 'tt37', 'link40')" onMouseOut="HideTip('tt37')">MURGE_ForceNoFacto</a></td><td class=SDescription>Prevent Murge from running factorisation even if matrix has changed.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_ProductSetLocalNodeNbr" id=link41 onMouseOver="ShowTip(event, 'tt38', 'link41')" onMouseOut="HideTip('tt38')">MURGE_ProductSetLocalNodeNbr</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_ProductSetLocalNodeList" id=link42 onMouseOver="ShowTip(event, 'tt39', 'link42')" onMouseOut="HideTip('tt39')">MURGE_ProductSetLocalNodeList</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#MURGE_GetLocalProduct" id=link43 onMouseOver="ShowTip(event, 'tt40', 'link43')" onMouseOut="HideTip('tt40')">MURGE_GetLocalProduct</a></td><td class=SDescription>Perform the product A * X.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#MURGE_GetGlobalProduct" id=link44 onMouseOver="ShowTip(event, 'tt41', 'link44')" onMouseOut="HideTip('tt41')">MURGE_GetGlobalProduct</a></td><td class=SDescription>Perform the product A * X.</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGeneric"><div class=CTopic><h3 class=CTitle><a name="Authors"></a>Authors</h3><div class=CBody><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Mathieu Faverge</td><td class=CDLDescription><a href="#" onClick="location.href='mai' + 'lto:' + 'fav' + 'erge' + '@' + 'labr' + 'i.fr'; return false;" class=LEMail>fav<span style="display: none">.nosp@m.</span>erge<span>@</span>labr<span style="display: none">.nosp@m.</span>i.fr</a></td></tr><tr><td class=CDLEntry>Xavier Lacoste</td><td class=CDLDescription><a href="#" onClick="location.href='mai' + 'lto:' + 'xavier.'&nbsp; + 'lacoste' + '@' + 'inri' + 'a.fr'; return false;" class=LEMail>xavier.<span style="display: none">.nosp@m.</span>lacoste<span>@</span>inri<span style="display: none">.nosp@m.</span>a.fr</a></td></tr></table></div></div></div>

<div class="CSection"><div class=CTopic><h2 class=CTitle><a name="Structures"></a>Structures</h2><div class=CBody></div></div></div>

<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="ijv_"></a>ijv_</h2><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">struct ijv_</td></tr></table></blockquote><p>Structure to represente coefficients.</p><h4 class=CHeading>Contains</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>i</td><td class=CDLDescription>row</td></tr><tr><td class=CDLEntry>j</td><td class=CDLDescription>column</td></tr><tr><td class=CDLEntry>v</td><td class=CDLDescription>pointer to the value array (can be several degree of freedom)</td></tr><tr><td class=CDLEntry>owner</td><td class=CDLDescription>process which own the coefficient.</td></tr></table><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SGroup"><td class=SEntry><a href="#ijv_.Types" >Types</a></td><td class=SDescription></td></tr><tr class="SType SIndent1 SMarked"><td class=SEntry><a href="#ijv_.ijv_t" >ijv_t</a></td><td class=SDescription>Alias to structure <a href="#ijv_" class=LClass id=link46 onMouseOver="ShowTip(event, 'tt2', 'link46')" onMouseOut="HideTip('tt2')">ijv_</a>.</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="ijv_.Types"></a>Types</h3></div></div>

<div class="CType"><div class=CTopic><h3 class=CTitle><a name="ijv_.ijv_t"></a>ijv_t</h3><div class=CBody><p>Alias to structure <a href="#ijv_" class=LClass id=link47 onMouseOver="ShowTip(event, 'tt2', 'link47')" onMouseOut="HideTip('tt2')">ijv_</a>.</p></div></div></div>

<div class="CClass"><div class=CTopic><h2 class=CTitle><a name="murge_data_t"></a>murge_data_t</h2><div class=CBody><p>Structure used to store murge data</p><h4 class=CHeading>Contians</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>pastix_data</td><td class=CDLDescription>Pointer to the <a href="pastixstr-h.html#pastix_data_t" class=LClass id=link48 onMouseOver="ShowTip(event, 'tt42', 'link48')" onMouseOut="HideTip('tt42')">pastix_data_t</a> associated to the solver instance</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>Number of local column indicated by murge user</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Number of global column indicated by murge user</td></tr><tr><td class=CDLEntry>colptr</td><td class=CDLDescription>Colptr in murge&rsquo;s user CSCd</td></tr><tr><td class=CDLEntry>rows</td><td class=CDLDescription>Rows in murge&rsquo;s user CSCd</td></tr><tr><td class=CDLEntry>values</td><td class=CDLDescription>Values in murge&rsquo;s user CSCd</td></tr><tr><td class=CDLEntry>l2g</td><td class=CDLDescription>Local 2 global column number in murge&rsquo;s user CSCd</td></tr><tr><td class=CDLEntry>perm</td><td class=CDLDescription>Permtab for murge&rsquo;s user</td></tr><tr><td class=CDLEntry>b</td><td class=CDLDescription>Right-hand-side member(s) given by murge&rsquo;s user</td></tr><tr><td class=CDLEntry>nrhs</td><td class=CDLDescription>Number of right-hand-side member(s) given by murge&rsquo;s user</td></tr><tr><td class=CDLEntry>tmpv</td><td class=CDLDescription>Temporary values array</td></tr><tr><td class=CDLEntry>tmpv_node</td><td class=CDLDescription>Temporary values array (node entries)</td></tr><tr><td class=CDLEntry>tmpijv</td><td class=CDLDescription>Temporary ijv structure array</td></tr><tr><td class=CDLEntry>cnt</td><td class=CDLDescription>Iterator for number of entered edges</td></tr><tr><td class=CDLEntry>edgenbr</td><td class=CDLDescription>Number of edges</td></tr><tr><td class=CDLEntry>state</td><td class=CDLDescription>State of the solver</td></tr><tr><td class=CDLEntry>mode</td><td class=CDLDescription>Local entries or communicating mode</td></tr><tr><td class=CDLEntry>op</td><td class=CDLDescription>Operation to perform when a coefficient appear twice</td></tr><tr><td class=CDLEntry>op2</td><td class=CDLDescription>Operation to perform when a coefficient appear twice, given by two processors.</td></tr><tr><td class=CDLEntry>sym</td><td class=CDLDescription>Indicate if we have to check that the matrix is symmetric</td></tr></table><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SGroup"><td class=SEntry><a href="#murge_data_t.Types" >Types</a></td><td class=SDescription></td></tr><tr class="SType SIndent1 SMarked"><td class=SEntry><a href="#murge_data_t.murge_data_t" >murge_data_t</a></td><td class=SDescription>alias to structure &lt;murge_data_&gt;.</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="murge_data_t.Types"></a>Types</h3></div></div>

<div class="CType"><div class=CTopic><h3 class=CTitle><a name="murge_data_t.murge_data_t"></a>murge_data_t</h3><div class=CBody><p>alias to structure &lt;murge_data_&gt;.</p></div></div></div>

<div class="CSection"><div class=CTopic><h2 class=CTitle><a name="Global_variables"></a>Global variables</h2><div class=CBody><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SGroup"><td class=SEntry><a href="#Variables" >Variables</a></td><td class=SDescription></td></tr><tr class="SVariable SIndent1 SMarked"><td class=SEntry><a href="#Global_variables" >Global variables</a></td><td class=SDescription></td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Variables"></a>Variables</h3></div></div>

<div class="CVariable"><div class=CTopic><h3 class=CTitle><a name="Global_variables"></a>Global variables</h3><div class=CBody><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry><a name="idnbr"></a>idnbr</td><td class=CDLDescription>Number of solvers instances.</td></tr><tr><td class=CDLEntry><a name="solvers"></a>solvers</td><td class=CDLDescription>Murge solver instances array (<a href="#murge_data_t" class=LClass id=link49 onMouseOver="ShowTip(event, 'tt43', 'link49')" onMouseOut="HideTip('tt43')">murge_data_t</a>).</td></tr></table></div></div></div>

<div class="CSection"><div class=CTopic><h2 class=CTitle><a name="Functions"></a>Functions</h2><div class=CBody><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SGroup"><td class=SEntry><a href="#Auxilary_functions" >Auxilary functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#check_preprocessing" id=link50 onMouseOver="ShowTip(event, 'tt3', 'link50')" onMouseOut="HideTip('tt3')">check_preprocessing</a></td><td class=SDescription>Checks if preprocessing (blend) has been called.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#cmp_ijv" id=link51 onMouseOver="ShowTip(event, 'tt4', 'link51')" onMouseOut="HideTip('tt4')">cmp_ijv</a></td><td class=SDescription>Compare to &lt;ijv_t&gt; structures on their column value (j) then, if equal, their row value (i).</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MurgeTmpijvOwnSort" id=link52 onMouseOver="ShowTip(event, 'tt5', 'link52')" onMouseOut="HideTip('tt5')">MurgeTmpijvOwnSort</a></td><td class=SDescription>Sort ijv_t structure, sorting also associated values. </td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MurgeTmpijvSort" id=link53 onMouseOver="ShowTip(event, 'tt6', 'link53')" onMouseOut="HideTip('tt6')">MurgeTmpijvSort</a></td><td class=SDescription>Sort ijv_t structure, sorting also associated values. </td></tr><tr class="SGroup"><td class=SEntry><a href="#Solver_setup_functions" >Solver setup functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_GetSolver" id=link54 onMouseOver="ShowTip(event, 'tt7', 'link54')" onMouseOut="HideTip('tt7')">MURGE_GetSolver</a></td><td class=SDescription>returns MURGE_SOLVER_PASTIX</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_Initialize" id=link55 onMouseOver="ShowTip(event, 'tt8', 'link55')" onMouseOut="HideTip('tt8')">MURGE_Initialize</a></td><td class=SDescription>Allocate the instance arrays which will keeps intern data for all solver instances.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_SetDefaultOptions" id=link56 onMouseOver="ShowTip(event, 'tt9', 'link56')" onMouseOut="HideTip('tt9')">MURGE_SetDefaultOptions</a></td><td class=SDescription>Create a solver instance if not created yet.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_SetOptionINT" id=link57 onMouseOver="ShowTip(event, 'tt10', 'link57')" onMouseOut="HideTip('tt10')">MURGE_SetOptionINT</a></td><td class=SDescription>Sets integer option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_SetOptionREAL" id=link58 onMouseOver="ShowTip(event, 'tt11', 'link58')" onMouseOut="HideTip('tt11')">MURGE_SetOptionREAL</a></td><td class=SDescription>Sets real option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_SetCommunicator" id=link59 onMouseOver="ShowTip(event, 'tt12', 'link59')" onMouseOut="HideTip('tt12')">MURGE_SetCommunicator</a></td><td class=SDescription>Sets MPI communicator for the given solver instance.</td></tr><tr class="SGroup"><td class=SEntry><a href="#I/O_functions" >I/<wbr>O functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_Save" id=link60 onMouseOver="ShowTip(event, 'tt13', 'link60')" onMouseOut="HideTip('tt13')">MURGE_Save</a></td><td class=SDescription>Runs preprocessing step, if not done yet, and save the result to disk, into <b>directory</b>, so that it can be resume using <a href="#MURGE_Load" class=LFunction id=link61 onMouseOver="ShowTip(event, 'tt14', 'link61')" onMouseOut="HideTip('tt14')">MURGE_Load</a>.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_Load" id=link62 onMouseOver="ShowTip(event, 'tt14', 'link62')" onMouseOut="HideTip('tt14')">MURGE_Load</a></td><td class=SDescription>Loads preprocessing result from disk, into <b>directory</b>, where it had been saved by <a href="#MURGE_Save" class=LFunction id=link63 onMouseOver="ShowTip(event, 'tt13', 'link63')" onMouseOut="HideTip('tt13')">MURGE_Save</a>.</td></tr><tr class="SGroup"><td class=SEntry><a href="#Getting_solver's_distribution" >Getting solver&rsquo;s distribution</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_GetLocalNodeNbr" id=link64 onMouseOver="ShowTip(event, 'tt15', 'link64')" onMouseOut="HideTip('tt15')">MURGE_GetLocalNodeNbr</a></td><td class=SDescription>Computes preprocessing step, if not done, and the number of Nodes in the new ditribution of the matrix.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_GetLocalNodeList" id=link65 onMouseOver="ShowTip(event, 'tt16', 'link65')" onMouseOut="HideTip('tt16')">MURGE_GetLocalNodeList</a></td><td class=SDescription>Computes the local node list, corresponding to the new distribution, after preprocessing.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_GetLocalUnkownNbr" >MURGE_GetLocalUnkownNbr</a></td><td class=SDescription>Computes preprocessing step, if not done, and the number of Unkowns in the new ditribution of the matrix.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_GetLocalUnkownList" >MURGE_GetLocalUnkownList</a></td><td class=SDescription>Computes the local unkown list, corresponding to the new distribution, after preprocessing.</td></tr><tr class="SGroup"><td class=SEntry><a href="#Graph_setup_functions" >Graph setup functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_GraphBegin" id=link66 onMouseOver="ShowTip(event, 'tt17', 'link66')" onMouseOut="HideTip('tt17')">MURGE_GraphBegin</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_GraphEdge" id=link67 onMouseOver="ShowTip(event, 'tt18', 'link67')" onMouseOut="HideTip('tt18')">MURGE_GraphEdge</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_GraphEnd" id=link68 onMouseOver="ShowTip(event, 'tt19', 'link68')" onMouseOut="HideTip('tt19')">MURGE_GraphEnd</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_GraphGlobalCSR" id=link69 onMouseOver="ShowTip(event, 'tt20', 'link69')" onMouseOut="HideTip('tt20')">MURGE_GraphGlobalCSR</a></td><td class=SDescription>Enter the adjency graph in a Column Sparse Row form.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_GraphGlobalCSC" id=link70 onMouseOver="ShowTip(event, 'tt21', 'link70')" onMouseOut="HideTip('tt21')">MURGE_GraphGlobalCSC</a></td><td class=SDescription>Distribute the CSC on the processors and use it for PaStiX calls.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_GraphGlobalIJV" id=link71 onMouseOver="ShowTip(event, 'tt22', 'link71')" onMouseOut="HideTip('tt22')">MURGE_GraphGlobalIJV</a></td><td class=SDescription>Distribute the graph on the processors, compress the columns array and use the built CSCd to call PaStiX.</td></tr><tr class="SGroup"><td class=SEntry><a href="#Matrix_assembly_functions" >Matrix assembly functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_AssemblyBegin" id=link72 onMouseOver="ShowTip(event, 'tt23', 'link72')" onMouseOut="HideTip('tt23')">MURGE_AssemblyBegin</a></td><td class=SDescription>Check that preprocessing has been performed, if not performs it.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_AssemblyEnd" id=link73 onMouseOver="ShowTip(event, 'tt24', 'link73')" onMouseOut="HideTip('tt24')">MURGE_AssemblyEnd</a></td><td class=SDescription>We have on each proc a part of the matrix in two structure, one containing nodes to add to the CSCd the other containing simple values.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_MatrixGlobalCSC" id=link74 onMouseOver="ShowTip(event, 'tt25', 'link74')" onMouseOut="HideTip('tt25')">MURGE_MatrixGlobalCSC</a></td><td class=SDescription>Give a CSC on one processor to PaStiX.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_MatrixGlobalIJV" id=link75 onMouseOver="ShowTip(event, 'tt26', 'link75')" onMouseOut="HideTip('tt26')">MURGE_MatrixGlobalIJV</a></td><td class=SDescription>Add the given global Compress Sparse Column matrix to the matrix.</td></tr><tr class="SGroup"><td class=SEntry><a href="#Filling_the_right-hand-side_member" >Filling the right-hand-side member</a></td><td class=SDescription></td></tr><tr class="SGroup"><td class=SEntry><a href="#Getting_the_solution" >Getting the solution</a></td><td class=SDescription></td></tr><tr class="SGroup"><td class=SEntry><a href="#Cleaning_up_this_mess" >Cleaning up this mess</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_PrintError" id=link76 onMouseOver="ShowTip(event, 'tt27', 'link76')" onMouseOut="HideTip('tt27')">MURGE_PrintError</a></td><td class=SDescription>Print the error message corresponding to ierror Parameters: error_number  - Error identification number.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_ExitOnError" id=link77 onMouseOver="ShowTip(event, 'tt28', 'link77')" onMouseOut="HideTip('tt28')">MURGE_ExitOnError</a></td><td class=SDescription>Print the error message corresponding to ierror. </td></tr><tr class="SGroup"><td class=SEntry><a href="#Scaling" >Scaling</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_GetGlobalNorm" id=link78 onMouseOver="ShowTip(event, 'tt29', 'link78')" onMouseOut="HideTip('tt29')">MURGE_GetGlobalNorm</a></td><td class=SDescription>Compute the global norm array following a norm rule.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_GetLocalNorm" id=link79 onMouseOver="ShowTip(event, 'tt30', 'link79')" onMouseOut="HideTip('tt30')">MURGE_GetLocalNorm</a></td><td class=SDescription>Compute the local norm array following a norm rule.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_GetNorm" id=link80 onMouseOver="ShowTip(event, 'tt31', 'link80')" onMouseOut="HideTip('tt31')">MURGE_GetNorm</a></td><td class=SDescription>Compute the indicated part of the norm array following a norm rule.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_ApplyGlobalScaling" id=link81 onMouseOver="ShowTip(event, 'tt32', 'link81')" onMouseOut="HideTip('tt32')">MURGE_ApplyGlobalScaling</a></td><td class=SDescription>Apply scaling to local unknowns.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_ApplyLocalScaling" id=link82 onMouseOver="ShowTip(event, 'tt33', 'link82')" onMouseOut="HideTip('tt33')">MURGE_ApplyLocalScaling</a></td><td class=SDescription>Apply the local scaling array on the matrix.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_ApplyScaling" id=link83 onMouseOver="ShowTip(event, 'tt34', 'link83')" onMouseOut="HideTip('tt34')">MURGE_ApplyScaling</a></td><td class=SDescription>Apply the scaling array on the indicated part of the matrix</td></tr><tr class="SGroup"><td class=SEntry><a href="#Specific_PaStiX_functions" >Specific PaStiX functions.</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_Analyze" id=link84 onMouseOver="ShowTip(event, 'tt35', 'link84')" onMouseOut="HideTip('tt35')">MURGE_Analyze</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_Factorize" id=link85 onMouseOver="ShowTip(event, 'tt36', 'link85')" onMouseOut="HideTip('tt36')">MURGE_Factorize</a></td><td class=SDescription>Perform matrix factorization.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_ForceNoFacto" id=link86 onMouseOver="ShowTip(event, 'tt37', 'link86')" onMouseOut="HideTip('tt37')">MURGE_ForceNoFacto</a></td><td class=SDescription>Prevent Murge from running factorisation even if matrix has changed.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_ProductSetLocalNodeNbr" id=link87 onMouseOver="ShowTip(event, 'tt38', 'link87')" onMouseOut="HideTip('tt38')">MURGE_ProductSetLocalNodeNbr</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_ProductSetLocalNodeList" id=link88 onMouseOver="ShowTip(event, 'tt39', 'link88')" onMouseOut="HideTip('tt39')">MURGE_ProductSetLocalNodeList</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#MURGE_GetLocalProduct" id=link89 onMouseOver="ShowTip(event, 'tt40', 'link89')" onMouseOut="HideTip('tt40')">MURGE_GetLocalProduct</a></td><td class=SDescription>Perform the product A * X.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#MURGE_GetGlobalProduct" id=link90 onMouseOver="ShowTip(event, 'tt41', 'link90')" onMouseOut="HideTip('tt41')">MURGE_GetGlobalProduct</a></td><td class=SDescription>Perform the product A * X.</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Auxilary_functions"></a>Auxilary functions</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="check_preprocessing"></a>check_preprocessing</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>static inline int check_preprocessing(</td><td class="PType  prettyprint " nowrap>int&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Checks if preprocessing (blend) has been called.</p><p>If it hasn&rsquo;t, it will allocate permutation tabular and call preprocessing step.</p><p>After calling preprocessing, it will set local number of column and local to global column number tabular to their new values.</p><p>Colptr and rows will be destroyed because it is obsolete, and state will be set to indicate that preprocessing has been performed.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance ID we want to check</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_ERR_ALLOCATE</td><td class=CDLDescription>If any allocation error occurs.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="cmp_ijv"></a>cmp_ijv</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>static int cmp_ijv(</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>p1,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>p2</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Compare to &lt;ijv_t&gt; structures on their column value (j) then, if equal, their row value (i).</p><p>Used for qsort.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>p1</td><td class=CDLDescription>pointer to the first element.</td></tr><tr><td class=CDLEntry>p2</td><td class=CDLDescription>pointer to the second element.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>A positive number</td><td class=CDLDescription>if p1.j &gt; p2.j or p1.j == p2.j and pi.i &gt; pi.j</td></tr><tr><td class=CDLEntry>0</td><td class=CDLDescription>if columns and rows are aquals.</td></tr><tr><td class=CDLEntry>A negative number</td><td class=CDLDescription>otherwise.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MurgeTmpijvOwnSort"></a>MurgeTmpijvOwnSort</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "colspan=2>#define INTSORTNAME MurgeTmpijvOwnSort #define INTSORTSIZE(</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>x</td></tr><tr><td class="PAfterParameters  prettyprint "colspan=2>) (sizeof (ijv_t)) #define INTSORTNTAB 1 #define OWNER(p) ((ijv_t *) (p))-&gt;owner #define IJV_T_J(p) ((ijv_t *) (p))-&gt;j #define IJV_T_I(p) ((ijv_t *) (p))-&gt;i #define IJV_T_INDEX(p) ((ijv_t *) (p))-&gt;idx #define INTSORTSWAP(p,q) do</td></tr></table></td></tr></table></blockquote><p>Sort ijv_t structure, sorting also associated values.&nbsp; Sort following owner, then j and then i.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>pbase</td><td class=CDLDescription>Array of two pointers, one  to the first element of the array to sort, and the second to dofnbr.</td></tr><tr><td class=CDLEntry>total_elems</td><td class=CDLDescription>Number of element in the array.</td></tr></table><h4 class=CHeading>Returns</h4><p>Nothing</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MurgeTmpijvSort"></a>MurgeTmpijvSort</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "colspan=2>#define INTSORTNAME MurgeTmpijvSort #define INTSORTSIZE(</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>x</td></tr><tr><td class="PAfterParameters  prettyprint "colspan=2>) (sizeof (ijv_t)) #define INTSORTNTAB 1 #define OWNER(p) ((ijv_t *) (p))-&gt;owner #define IJV_T_J(p) ((ijv_t *) (p))-&gt;j #define IJV_T_I(p) ((ijv_t *) (p))-&gt;i #define INTSORTSWAP(p,q) do</td></tr></table></td></tr></table></blockquote><p>Sort ijv_t structure, sorting also associated values.&nbsp; Sort following j and then i.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>pbase</td><td class=CDLDescription>Array of two pointers, one  to the first element of the array to sort, and the second to dofnbr.</td></tr><tr><td class=CDLEntry>total_elems</td><td class=CDLDescription>Number of element in the array.</td></tr></table><h4 class=CHeading>Returns</h4><p>Nothing</p></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Solver_setup_functions"></a>Solver setup functions</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetSolver"></a>MURGE_GetSolver</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetSolver(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>solver_id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>returns MURGE_SOLVER_PASTIX</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_Initialize"></a>MURGE_Initialize</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Initialize(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id_nbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Allocate the instance arrays which will keeps intern data for all solver instances.</p><p>If user is creating several threads calling the solver, this function has to be called before creating threads to insure solver is thread safe.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>idnbr</td><td class=CDLDescription>Maximum number of solver instances that will be launched.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ALLOCATE</td><td class=CDLDescription>If for some reason, allocation was not successfull.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetDefaultOptions"></a>MURGE_SetDefaultOptions</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetDefaultOptions(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>stratnum</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Create a solver instance if not created yet.</p><p>Sets default options, for solver instance number <b>id</b>.</p><p>The default option set correspond to <b>stratnum</b> strategy ID, depending on the solver.</p><p>Needs <a href="#MURGE_Initialize" class=LFunction id=link91 onMouseOver="ShowTip(event, 'tt8', 'link91')" onMouseOut="HideTip('tt8')">MURGE_Initialize</a> to be called before to allocate solver instances array.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>stratnum</td><td class=CDLDescription>Strategy for the default option Set.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If <a href="#MURGE_Initialize" class=LFunction id=link92 onMouseOver="ShowTip(event, 'tt8', 'link92')" onMouseOut="HideTip('tt8')">MURGE_Initialize</a> was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>stratnum</b> is not valid.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ALLOCATE</td><td class=CDLDescription>If couldn&rsquo;t create solver instance.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetOptionINT"></a>MURGE_SetOptionINT</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetOptionINT (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>number,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Sets integer option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</p><p>Needs &lt;MURGE_SetDefaultOption&gt; to be called before to initiate solver instance data.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>number</td><td class=CDLDescription>Identification of the integer parameter.</td></tr><tr><td class=CDLEntry>value</td><td class=CDLDescription>value to set the parameter to.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If &lt;MURGE_SetDefaultOption&gt; was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>number</b> or <b>value</b> are not valid.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetOptionREAL"></a>MURGE_SetOptionREAL</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetOptionREAL(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>number,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Sets real option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</p><p>Needs &lt;MURGE_SetDefaultOption&gt; to be called before to initiate solver instance data.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>number</td><td class=CDLDescription>Identification of the integer parameter.</td></tr><tr><td class=CDLEntry>value</td><td class=CDLDescription>value to set the parameter to.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If &lt;MURGE_SetDefaultOption&gt; was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>number</b> or <b>value</b> are not valid.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_SetCommunicator"></a>MURGE_SetCommunicator</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetCommunicator(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>MPI_Comm&nbsp;</td><td class="PParameter  prettyprint " nowrap>mpicomm</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Sets MPI communicator for the given solver instance.</p><p>Needs &lt;MURGE_SetDefaultOption&gt; to be called before to initiate solver instance data.</p><p>Musn&rsquo;t be called before &lt;MURGE_SAVE&gt;, &lt;MURGE_LOAD&gt;, <a href="#MURGE_GetLocalNodeNbr" class=LFunction id=link93 onMouseOver="ShowTip(event, 'tt15', 'link93')" onMouseOut="HideTip('tt15')">MURGE_GetLocalNodeNbr</a> nor <a href="../../murge/include/murge-h.html#MURGE_GetLocalUnknownNbr" class=LFunction id=link94 onMouseOver="ShowTip(event, 'tt44', 'link94')" onMouseOut="HideTip('tt44')">MURGE_GetLocalUnknownNbr</a> because the solver as to be runned with the same MPI communicator all along.</p><p>If this function is not called, MPI communicator will be <b>MPI_COMM_WORLD</b>.</p><p>This function may not exist if the solver has been compiled without MPI.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>mpicomm</td><td class=CDLDescription>MPI communicator to affect the solver to.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If &lt;MURGE_SetDefaultOption&gt; was not called before or if it is called after the solver starts its computing tasks.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>number</b> or <b>value</b> are not valid.</td></tr></table></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="I/O_functions"></a>I/<wbr>O functions</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_Save"></a>MURGE_Save</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Save(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>directory</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Runs preprocessing step, if not done yet, and save the result to disk, into <b>directory</b>, so that it can be resume using <a href="#MURGE_Load" class=LFunction id=link95 onMouseOver="ShowTip(event, 'tt14', 'link95')" onMouseOut="HideTip('tt14')">MURGE_Load</a>.</p><p>Needs &lt;MURGE_SetDefaultOption&gt; to be called before to initiate solver instance data.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>directory</td><td class=CDLDescription>Path to the directory where to save the solver step.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If &lt;MURGE_SetDefaultOption&gt; was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_IO</td><td class=CDLDescription>If file(s) couldn&rsquo;t be writen.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_Load"></a>MURGE_Load</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Load(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>directory</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Loads preprocessing result from disk, into <b>directory</b>, where it had been saved by <a href="#MURGE_Save" class=LFunction id=link96 onMouseOver="ShowTip(event, 'tt13', 'link96')" onMouseOut="HideTip('tt13')">MURGE_Save</a>.</p><p>If preprocessing data was already computed or loaded, it will be overwriten.</p><p>Needs &lt;MURGE_SetDefaultOption&gt; to be called before to initiate solver instance data.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>directory</td><td class=CDLDescription>Path to the directory where to load the solver preprocessing data.</td></tr></table><p>In Fortran, <b>STR_LEN</b> is the length of the string directory.</p><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If &lt;MURGE_SetDefaultOption&gt; was not called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_IO</td><td class=CDLDescription>If file(s) couldn&rsquo;t be read.</td></tr></table></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Getting_solver's_distribution"></a>Getting solver&rsquo;s distribution</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalNodeNbr"></a>MURGE_GetLocalNodeNbr</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNodeNbr (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>nodenbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Computes preprocessing step, if not done, and the number of Nodes in the new ditribution of the matrix.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>nodenbr</td><td class=CDLDescription><b>INTS</b> where to store number of nodes.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>nodenbr</b> is <b>NULL</b> (can occur in C).</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalNodeList"></a>MURGE_GetLocalNodeList</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNodeList (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>nodelist</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Computes the local node list, corresponding to the new distribution, after preprocessing.</p><p><b>nodelist</b> array has to be allocated before calling this function.</p><p>As it&rsquo;s result determines the size of <b>nodelist</b> array, <a href="#MURGE_GetLocalNodeNbr" class=LFunction id=link97 onMouseOver="ShowTip(event, 'tt15', 'link97')" onMouseOut="HideTip('tt15')">MURGE_GetLocalNodeNbr</a> should be run before it.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>nodelist</td><td class=CDLDescription>Array where to store the list of local nodes.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>if <a href="#MURGE_GetLocalNodeNbr" class=LFunction id=link98 onMouseOver="ShowTip(event, 'tt15', 'link98')" onMouseOut="HideTip('tt15')">MURGE_GetLocalNodeNbr</a> has not been called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>nodelist</b> is <b>NULL</b> (can occur in C).</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalUnkownNbr"></a>MURGE_GetLocalUnkownNbr</h3><div class=CBody><p>Computes preprocessing step, if not done, and the number of Unkowns in the new ditribution of the matrix.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>unkownnbr</td><td class=CDLDescription><b>INTS</b> where to store number of unkowns.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>unkownnbr</b> is <b>NULL</b> (can occur in C).</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalUnkownList"></a>MURGE_GetLocalUnkownList</h3><div class=CBody><p>Computes the local unkown list, corresponding to the new distribution, after preprocessing.</p><p><b>unkownlist</b> array has to be allocated before calling this function.</p><p>As it&rsquo;s result determines the size of <b>unkownlist</b> array, <a href="#MURGE_GetLocalUnkownNbr" class=LFunction id=link99 onMouseOver="ShowTip(event, 'tt45', 'link99')" onMouseOut="HideTip('tt45')">MURGE_GetLocalUnkownNbr</a> should be run before it.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>unkownlist</td><td class=CDLDescription>Array where to store the list of local unkowns.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>if <a href="#MURGE_GetLocalUnkownNbr" class=LFunction id=link100 onMouseOver="ShowTip(event, 'tt45', 'link100')" onMouseOut="HideTip('tt45')">MURGE_GetLocalUnkownNbr</a> has not been called before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range or <b>unkownlist</b> is <b>NULL</b> (can occur in C).</td></tr></table></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Graph_setup_functions"></a>Graph setup functions</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphBegin"></a>MURGE_GraphBegin</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphBegin(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameter  prettyprint " nowrap>edgenbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><ul><li>Allocate temporary structure which will contain graph entries.</li><li>Set number of unkowns in the graph.</li><li>Set the number of entries that are expected in this building session.</li><li>Reset the number of entries for this build session.</li><li>Set all states except MURGE_GRAPH_BUILD to FALSE (graph, values, blend, nodelst, nodenbr, facto)</li></ul><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Number of unkowns.</td></tr><tr><td class=CDLEntry>edgenbr</td><td class=CDLDescription>Number of edges in this building session.&nbsp; If edgenbr is negative, PaStiX will perform dynamic reallocation of the array, with the first allocation of size -edgenbr.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>MURGE_GraphBegin has already been called, or if <b>solvers</b> or <b>solvers[id]</b> are not allocated, or if <b>iparm</b> or <b>dparm</b> are not allocated.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in correct range.</td></tr><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>Otherwise.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphEdge"></a>MURGE_GraphEdge</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphEdge (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>ROW,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>COL</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><ul><li>Check that the number of entries has not been reach for this session.</li><li>Increments ROW and COL if baseval is set to 0.</li><li>Checks that ROW and COL ranges are corrects.</li><li>Adds an entry to the temporary ijv structure.</li></ul><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>ROW</td><td class=CDLDescription>Row of the entry.</td></tr><tr><td class=CDLEntry>COL</td><td class=CDLDescription>Column of the entry.</td></tr></table><h4 class=CHeading>Return</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>if we are not in a graph building session, or if two many edges have been entered, or if <b>solvers</b> or <b>solvers[id]</b> are not allocated, or if <b>iparm</b> or <b>dparm</b> are not allocated.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription><b>ROW</b> or <b>COL</b> are out of range or if <b>id</b> is not in correct range.</td></tr><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>Otherwise</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphEnd"></a>MURGE_GraphEnd</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphEnd (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><ul><li>Sort temporary IJV structure with cols as key.</li><li>Distribute columns onto processors.&nbsp; (first column on first proc and so on...)</li><li>Build a distributed CSC that will be given to PaStiX.</li></ul><h4 class=CHeading>TODO</h4><ul><li>In the case of a triangular matrix, count each extra-diagonal twice.</li><li>Use initial distribution to compute column distribution, in order to reduce communications.</li></ul><p>Parameters : id  - Solver instance identification number.</p><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>if we are not in a graph building session, or if all edges have not been entered, or if <b>solvers</b> or <b>solvers[id]</b> are not allocated, or if <b>iparm</b> or <b>dparm</b> are not allocated.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription><b>ROW</b> or <b>COL</b> are out of range or if <b>id</b> is not in correct range.</td></tr><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>Otherwise</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphGlobalCSR"></a>MURGE_GraphGlobalCSR</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalCSR(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>rowptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Enter the adjency graph in a Column Sparse Row form.</p><p>If the matrix is symmetric, calls <a href="#MURGE_GraphGlobalCSC" class=LFunction id=link101 onMouseOver="ShowTip(event, 'tt21', 'link101')" onMouseOut="HideTip('tt21')">MURGE_GraphGlobalCSC</a> else uses <a href="#MURGE_GraphBegin" class=LFunction id=link102 onMouseOver="ShowTip(event, 'tt17', 'link102')" onMouseOut="HideTip('tt17')">MURGE_GraphBegin</a>, <a href="#MURGE_GraphEdge" class=LFunction id=link103 onMouseOver="ShowTip(event, 'tt18', 'link103')" onMouseOut="HideTip('tt18')">MURGE_GraphEdge</a>, <a href="#MURGE_GraphEnd" class=LFunction id=link104 onMouseOver="ShowTip(event, 'tt19', 'link104')" onMouseOut="HideTip('tt19')">MURGE_GraphEnd</a> sequence.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Number of rows in the CSR.</td></tr><tr><td class=CDLEntry>rowptr</td><td class=CDLDescription>Indexes of each row in COLS array.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Rank of the processor owning the CSR (-1 for all processors)</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphGlobalCSC"></a>MURGE_GraphGlobalCSC</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalCSC(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>colptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Distribute the CSC on the processors and use it for PaStiX calls.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Number of columns in the CSR.</td></tr><tr><td class=CDLEntry>colptr</td><td class=CDLDescription>Indexes of each columns in ROWS array.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Rank of the processor owning the CSR (-1 for all processors)</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GraphGlobalIJV"></a>MURGE_GraphGlobalIJV</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalIJV(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>NNZ,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Distribute the graph on the processors, compress the columns array and use the built CSCd to call PaStiX.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Number of columns in the CSR.</td></tr><tr><td class=CDLEntry>NNZ</td><td class=CDLDescription>Number of non-zeros in the matrix.</td></tr><tr><td class=CDLEntry>ROWS</td><td class=CDLDescription>Rows array.</td></tr><tr><td class=CDLEntry>COLS</td><td class=CDLDescription>Columns array.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Rank of the processor owning the CSR (-1 for all processors)</td></tr></table></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Matrix_assembly_functions"></a>Matrix assembly functions</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_AssemblyBegin"></a>MURGE_AssemblyBegin</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblyBegin(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameter  prettyprint " nowrap>coefnbr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>op2,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>mode,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Check that preprocessing has been performed, if not performs it.</p><p>Allocate ijv structure which will be used to store I,J,v[dof*dof].</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>op</td><td class=CDLDescription>Operation to perform for coefficient which appear several tim (see <a href="../../murge/include/murge-h.html#MURGE_ASSEMBLY_OP" class=LType id=link105 onMouseOver="ShowTip(event, 'tt46', 'link105')" onMouseOut="HideTip('tt46')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>op2</td><td class=CDLDescription>Operation to perform when a coefficient is set by two different processors (see <a href="../../murge/include/murge-h.html#MURGE_ASSEMBLY_OP" class=LType id=link106 onMouseOver="ShowTip(event, 'tt46', 'link106')" onMouseOut="HideTip('tt46')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>mode</td><td class=CDLDescription>Indicates if user ensure he will respect solvers distribution (see <a href="../../murge/include/murge-h.html#MURGE_ASSEMBLY_MODE" class=LType id=link107 onMouseOver="ShowTip(event, 'tt47', 'link107')" onMouseOut="HideTip('tt47')">MURGE_ASSEMBLY_MODE</a>).</td></tr><tr><td class=CDLEntry>sym</td><td class=CDLDescription>Indicates if user will give coefficient in a symmetric way (ie: only triangullar part) or not.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If graph hasn&rsquo;t been built before.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ALLOCATE</td><td class=CDLDescription>If Allocation didn&rsquo;t worked.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range, or <b>op</b>, <b>mode</b>, <b>sym</b>, or <b>coefnbr</b> are not valid.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_AssemblyEnd"></a>MURGE_AssemblyEnd</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblyEnd(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>We have on each proc a part of the matrix in two structure, one containing nodes to add to the CSCd the other containing simple values.</p><h4 class=CHeading>We send all data to his owner</h4><ul><li>We build glob2local array to determine if a column is local.</li><li>We sort our data structures (IJV structures) using the &ldquo;owner&rdquo; attribute.</li><li>We send non local data to other processors.</li></ul><p>We merge all data in the node structure.</p><ul><li>We receive Data and merge node structure with simple values one.</li><li>We look for each coef in node structure, if present we modify the node, if not, we search in the CSCd and directly modify it.&nbsp; Else we construct a new node and add it.</li></ul><p>We Add this structure to the local CSCd.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_MatrixGlobalCSC"></a>MURGE_MatrixGlobalCSC</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixGlobalCSC(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLPTR,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Give a CSC on one processor to PaStiX.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_MatrixGlobalIJV"></a>MURGE_MatrixGlobalIJV</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixGlobalIJV(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>NNZ,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Add the given global Compress Sparse Column matrix to the matrix.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>N</td><td class=CDLDescription>Number of edges.</td></tr><tr><td class=CDLEntry>NNZ</td><td class=CDLDescription>Number of non zeros.</td></tr><tr><td class=CDLEntry>ROWS</td><td class=CDLDescription>Global row number array.</td></tr><tr><td class=CDLEntry>COLS</td><td class=CDLDescription>Global column number array.</td></tr><tr><td class=CDLEntry>values</td><td class=CDLDescription>values array.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Root processor for MPI communications.</td></tr><tr><td class=CDLEntry>op</td><td class=CDLDescription>Operation to perform if a coefficient appear twice (see <a href="../../murge/include/murge-h.html#MURGE_ASSEMBLY_OP" class=LType id=link108 onMouseOver="ShowTip(event, 'tt46', 'link108')" onMouseOut="HideTip('tt46')">MURGE_ASSEMBLY_OP</a>).</td></tr><tr><td class=CDLEntry>sym</td><td class=CDLDescription>Indicates if user will give coefficient in a symmetric way (ie: only triangullar part) or not.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range, if <b>root</b>, <b>op</b>, <b>ROWS</b> or <b>COLS</b> are not valid.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_MATRIXGLOBALIJV(ID, N, NNZ, ROWS, COLS, VALUES, &amp;
                               &amp; ROOT, OP, SYM, IERROR)
  INTS,               INTENT(IN)  :: ID, ROOT, OP, SYM, N
  INTL,               INTENT(IN)  :: NNZ
  INTS, DIMENSION(0), INTENT(IN)  :: ROWS, COLS
  COEF, DIMENSION(0), INTENT(IN)  :: VALUES
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_MATRIXGLOBALIJV</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Filling_the_right-hand-side_member"></a>Filling the right-hand-side member</h3></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Getting_the_solution"></a>Getting the solution</h3></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Cleaning_up_this_mess"></a>Cleaning up this mess</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_PrintError"></a>MURGE_PrintError</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_PrintError(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>error_number</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Print the error message corresponding to ierror Parameters: error_number  - Error identification number.</p><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If ierror does not match an error number</td></tr><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_PRINTERROR(ERROR_NUMBER, IERROR)
  INTS, INTENT(IN)  :: IERROR
  INTS, INTENT(OUT) :: ERROR_NUMBER
END SUBROUTINE MURGE_PRINTERROR</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ExitOnError"></a>MURGE_ExitOnError</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ExitOnError(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>error_number</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Print the error message corresponding to ierror.&nbsp; If the ierr is not MURGE_SUCCESS then the program is stopped.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>ierror</td><td class=CDLDescription>Error identification number.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully, stop the program otherwise.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_EXITONERROR(ERROR_NUMBER, IERROR)
  INTS, INTENT(IN)  :: IERROR
  INTS, INTENT(OUT) :: ERROR_NUMBER
END SUBROUTINE MURGE_EXITONERROR</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Scaling"></a>Scaling</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetGlobalNorm"></a>MURGE_GetGlobalNorm</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetGlobalNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Compute the global norm array following a norm rule.</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>norm</td><td class=CDLDescription>Array of size global column number*dof which will contain the norm values</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Indicates which processor will have the norm array at the end of the call, -1 for all.</td></tr><tr><td class=CDLEntry>rule</td><td class=CDLDescription>Rule to follow to build norm array, see <a href="../../murge/include/murge-h.html#MURGE_NORM_RULES" class=LType id=link109 onMouseOver="ShowTip(event, 'tt48', 'link109')" onMouseOut="HideTip('tt48')">MURGE_NORM_RULES</a></td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETGLOBALNORM(ID, NORM, ROOT, RULE, IERROR)
  INTS,               INTENT(IN)  :: ID, ROOT, RULE
  REAL, DIMENSION(0), INTENT(OUT) :: NORM
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETGLOBALNORM</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalNorm"></a>MURGE_GetLocalNorm</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Compute the local norm array following a norm rule.</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>norm</td><td class=CDLDescription>Array of size local column number*dof which will contain the solution</td></tr><tr><td class=CDLEntry>rule</td><td class=CDLDescription>Rule to follow to build norm array, see <a href="../../murge/include/murge-h.html#MURGE_NORM_RULES" class=LType id=link110 onMouseOver="ShowTip(event, 'tt48', 'link110')" onMouseOut="HideTip('tt48')">MURGE_NORM_RULES</a></td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETLOCALNORM(ID, NORM, RULE, IERROR)
  INTS,               INTENT(IN)  :: ID, RULE
  REAL, DIMENSION(0), INTENT(OUT) :: NORM
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETLOCALNORM</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetNorm"></a>MURGE_GetNorm</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Compute the indicated part of the norm array following a norm rule.</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>Number of coefficients user wants to get norm of.</td></tr><tr><td class=CDLEntry>coefsidx</td><td class=CDLDescription>List of the coefficients user wants to get norm of.</td></tr><tr><td class=CDLEntry>norm</td><td class=CDLDescription>Array of size dof*n which will contain the solution.</td></tr><tr><td class=CDLEntry>rule</td><td class=CDLDescription>Rule to follow to build norm array, see <a href="../../murge/include/murge-h.html#MURGE_NORM_RULES" class=LType id=link111 onMouseOver="ShowTip(event, 'tt48', 'link111')" onMouseOut="HideTip('tt48')">MURGE_NORM_RULES</a></td></tr><tr><td class=CDLEntry>mode</td><td class=CDLDescription>Indicates if the user is sure to respect the distribution.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_GETNORM(ID, N, COEFSIDX, NORM, RULE, MODE, IERROR)
  INTS,               INTENT(IN)  :: ID, MODE, N, RULE
  INTS, DIMENSION(0), INTENT(IN)  :: COEFSIDX
  COEF, DIMENSION(0), INTENT(OUT) :: NORM
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_GETNORM</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ApplyGlobalScaling"></a>MURGE_ApplyGlobalScaling</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyGlobalScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Apply scaling to local unknowns.</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>scal</td><td class=CDLDescription>Scaling user wants to apply.</td></tr><tr><td class=CDLEntry>sc_mode</td><td class=CDLDescription>Indicate if the scaling is applied on rows or on columns.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Indicates which processor that posses the scaling array, -1 for all.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_APPLYGLOBALSCALING(ID, SCAL, SC_MODE, ROOT, IERROR)
  INTS,               INTENT(IN)  :: ID, ROOT, SC_MODE
  REAL, DIMENSION(0), INTENT(OUT) :: SCAL
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_APPLYGLOBALSCALING</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ApplyLocalScaling"></a>MURGE_ApplyLocalScaling</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyLocalScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Apply the local scaling array on the matrix.</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>scal</td><td class=CDLDescription>Array of size local column number*dof which will contain the solution.</td></tr><tr><td class=CDLEntry>sc_mode</td><td class=CDLDescription>Indicate if the scaling is applied on rows or on columns.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_APPLYLOCALSCALING(ID, SCAL, SC_MODE, IERROR)
  INTS,               INTENT(IN)  :: ID, SC_MODE
  REAL, DIMENSION(0), INTENT(OUT) :: SCAL
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_APPLYLOCALSCALING</pre></blockquote></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ApplyScaling"></a>MURGE_ApplyScaling</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Apply the scaling array on the indicated part of the matrix</p><p>Must be performed after assembly step.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>Number of coefficients user wants to scale.</td></tr><tr><td class=CDLEntry>coefsidx</td><td class=CDLDescription>List of the coefficients user wants to scale.</td></tr><tr><td class=CDLEntry>scal</td><td class=CDLDescription>Array of size dof*n which will contain the solution.</td></tr><tr><td class=CDLEntry>sc_mode</td><td class=CDLDescription>Indicate if the scaling is applied on rows or on columns.</td></tr><tr><td class=CDLEntry>mode</td><td class=CDLDescription>Indicates if the user is sure to respect the distribution.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned successfully.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>id</b> is not in solver arrays range.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If the assembly has not been performed.</td></tr></table><h4 class=CHeading>Fortran interface</h4><blockquote><pre>SUBROUTINE MURGE_APPLYSCALING(ID, N, COEFSIDX, SCAL, SC_MODE, MODE, IERROR)
  INTS,               INTENT(IN)  :: ID, SC_MODE, MODE, N
  INTS, DIMENSION(0), INTENT(IN)  :: COEFSIDX
  COEF, DIMENSION(0), INTENT(OUT) :: SCAL
  INTS,               INTENT(OUT) :: IERROR
END SUBROUTINE MURGE_APPLYSCALING</pre></blockquote></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Specific_PaStiX_functions"></a>Specific PaStiX functions.</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_Analyze"></a>MURGE_Analyze</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Analyze(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><h4 class=CHeading>Perform matrix analyze</h4><ul><li>Compute a new ordering of the unknows</li><li>Compute the symbolic factorisation of the matrix</li><li>Distribute column blocks and computation on processors</li></ul><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned succesfuly.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If function the graph is not built.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>murge_id</b> is not a valid ID.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_Factorize"></a>MURGE_Factorize</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Factorize(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Perform matrix factorization.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>MURGE_SUCCESS</td><td class=CDLDescription>If function runned succesfuly.</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If function the graph is not built.</td></tr><tr><td class=CDLEntry>MURGE_ERR_PARAMETER</td><td class=CDLDescription>If <b>murge_id</b> is not a valid ID.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ForceNoFacto"></a>MURGE_ForceNoFacto</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ForceNoFacto(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Prevent Murge from running factorisation even if matrix has changed.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.&nbsp; Returns: MURGE_SUCCESS</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ProductSetLocalNodeNbr"></a>MURGE_ProductSetLocalNodeNbr</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ProductSetLocalNodeNbr (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>n</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>Number of local nodes.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_ProductSetLocalNodeList"></a>MURGE_ProductSetLocalNodeList</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ProductSetLocalNodeList (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>l2g</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>l2g</td><td class=CDLDescription>Local to global node numbers.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetLocalProduct"></a>MURGE_GetLocalProduct</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalProduct (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>x</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Perform the product A * X.</p><p>The vector must have been given trough <a href="../../murge/include/murge-h.html#MURGE_SetLocalRHS" class=LFunction id=link112 onMouseOver="ShowTip(event, 'tt49', 'link112')" onMouseOut="HideTip('tt49')">MURGE_SetLocalRHS</a> or <a href="../../murge/include/murge-h.html#MURGE_SetGlobalRHS" class=LFunction id=link113 onMouseOver="ShowTip(event, 'tt50', 'link113')" onMouseOut="HideTip('tt50')">MURGE_SetGlobalRHS</a>.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>x</td><td class=CDLDescription>Array in which the local part of the product will be stored.&nbsp; Returns:</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If values have not been set.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="MURGE_GetGlobalProduct"></a>MURGE_GetGlobalProduct</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetGlobalProduct (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>x,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Perform the product A * X.</p><p>The vector must have been given trough <a href="../../murge/include/murge-h.html#MURGE_SetLocalRHS" class=LFunction id=link114 onMouseOver="ShowTip(event, 'tt49', 'link114')" onMouseOut="HideTip('tt49')">MURGE_SetLocalRHS</a> or <a href="../../murge/include/murge-h.html#MURGE_SetGlobalRHS" class=LFunction id=link115 onMouseOver="ShowTip(event, 'tt50', 'link115')" onMouseOut="HideTip('tt50')">MURGE_SetGlobalRHS</a>.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>id</td><td class=CDLDescription>Solver instance identification number.</td></tr><tr><td class=CDLEntry>x</td><td class=CDLDescription>Array in which the product will be stored.</td></tr><tr><td class=CDLEntry>root</td><td class=CDLDescription>Rank of the process which will own the product at end of call, use -1 for all processes.&nbsp; Returns:</td></tr><tr><td class=CDLEntry>MURGE_ERR_ORDER</td><td class=CDLDescription>If values have not been set.</td></tr></table></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CSection>Murge is close to the Merge.</div></div><div class=CToolTip id="tt2"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">struct ijv_</td></tr></table></blockquote>Structure to represente coefficients.</div></div><div class=CToolTip id="tt3"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>static inline int check_preprocessing(</td><td class="PType  prettyprint " nowrap>int&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Checks if preprocessing (blend) has been called.</div></div><div class=CToolTip id="tt4"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>static int cmp_ijv(</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>p1,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>p2</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Compare to ijv_t structures on their column value (j) then, if equal, their row value (i).</div></div><div class=CToolTip id="tt5"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "colspan=2>#define INTSORTNAME MurgeTmpijvOwnSort #define INTSORTSIZE(</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>x</td></tr><tr><td class="PAfterParameters  prettyprint "colspan=2>) (sizeof (ijv_t)) #define INTSORTNTAB 1 #define OWNER(p) ((ijv_t *) (p))-&gt;owner #define IJV_T_J(p) ((ijv_t *) (p))-&gt;j #define IJV_T_I(p) ((ijv_t *) (p))-&gt;i #define IJV_T_INDEX(p) ((ijv_t *) (p))-&gt;idx #define INTSORTSWAP(p,q) do</td></tr></table></td></tr></table></blockquote>Sort ijv_t structure, sorting also associated values. </div></div><div class=CToolTip id="tt6"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "colspan=2>#define INTSORTNAME MurgeTmpijvSort #define INTSORTSIZE(</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>x</td></tr><tr><td class="PAfterParameters  prettyprint "colspan=2>) (sizeof (ijv_t)) #define INTSORTNTAB 1 #define OWNER(p) ((ijv_t *) (p))-&gt;owner #define IJV_T_J(p) ((ijv_t *) (p))-&gt;j #define IJV_T_I(p) ((ijv_t *) (p))-&gt;i #define INTSORTSWAP(p,q) do</td></tr></table></td></tr></table></blockquote>Sort ijv_t structure, sorting also associated values. </div></div><div class=CToolTip id="tt7"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetSolver(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>solver_id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>returns MURGE_SOLVER_PASTIX</div></div><div class=CToolTip id="tt8"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Initialize(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id_nbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Allocate the instance arrays which will keeps intern data for all solver instances.</div></div><div class=CToolTip id="tt9"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetDefaultOptions(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>stratnum</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Create a solver instance if not created yet.</div></div><div class=CToolTip id="tt10"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetOptionINT (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>number,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Sets integer option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</div></div><div class=CToolTip id="tt11"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetOptionREAL(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>number,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameter  prettyprint " nowrap>value</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Sets real option, indicated by <b>number</b>, to <b>value</b> for the solver instance number <b>id</b>.</div></div><div class=CToolTip id="tt12"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetCommunicator(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>MPI_Comm&nbsp;</td><td class="PParameter  prettyprint " nowrap>mpicomm</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Sets MPI communicator for the given solver instance.</div></div><div class=CToolTip id="tt13"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Save(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>directory</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Runs preprocessing step, if not done yet, and save the result to disk, into <b>directory</b>, so that it can be resume using MURGE_Load.</div></div><div class=CToolTip id="tt14"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Load(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>directory</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Loads preprocessing result from disk, into <b>directory</b>, where it had been saved by MURGE_Save.</div></div><div class=CToolTip id="tt15"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNodeNbr (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>nodenbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Computes preprocessing step, if not done, and the number of Nodes in the new ditribution of the matrix.</div></div><div class=CToolTip id="tt16"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNodeList (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>nodelist</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Computes the local node list, corresponding to the new distribution, after preprocessing.</div></div><div class=CToolTip id="tt17"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphBegin(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameter  prettyprint " nowrap>edgenbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote></div></div><div class=CToolTip id="tt18"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphEdge (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>ROW,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>COL</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote></div></div><div class=CToolTip id="tt19"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphEnd (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote></div></div><div class=CToolTip id="tt20"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalCSR(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>rowptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Enter the adjency graph in a Column Sparse Row form.</div></div><div class=CToolTip id="tt21"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalCSC(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>colptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Distribute the CSC on the processors and use it for PaStiX calls.</div></div><div class=CToolTip id="tt22"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GraphGlobalIJV(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>NNZ,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Distribute the graph on the processors, compress the columns array and use the built CSCd to call PaStiX.</div></div><div class=CToolTip id="tt23"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblyBegin(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameter  prettyprint " nowrap>coefnbr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>op2,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>mode,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Check that preprocessing has been performed, if not performs it.</div></div><div class=CToolTip id="tt24"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_AssemblyEnd(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>We have on each proc a part of the matrix in two structure, one containing nodes to add to the CSCd the other containing simple values.</div></div><div class=CToolTip id="tt25"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixGlobalCSC(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLPTR,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Give a CSC on one processor to PaStiX.</div></div><div class=CToolTip id="tt26"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_MatrixGlobalIJV(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>N,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>NNZ,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>ROWS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>COLS,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>values,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sym</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Add the given global Compress Sparse Column matrix to the matrix.</div></div><div class=CToolTip id="tt27"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_PrintError(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>error_number</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Print the error message corresponding to ierror Parameters: error_number  - Error identification number.</div></div><div class=CToolTip id="tt28"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ExitOnError(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>error_number</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Print the error message corresponding to ierror. </div></div><div class=CToolTip id="tt29"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetGlobalNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Compute the global norm array following a norm rule.</div></div><div class=CToolTip id="tt30"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Compute the local norm array following a norm rule.</div></div><div class=CToolTip id="tt31"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetNorm(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>norm,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>rule,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Compute the indicated part of the norm array following a norm rule.</div></div><div class=CToolTip id="tt32"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyGlobalScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Apply scaling to local unknowns.</div></div><div class=CToolTip id="tt33"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyLocalScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Apply the local scaling array on the matrix.</div></div><div class=CToolTip id="tt34"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ApplyScaling(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>n,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>coefsidx,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>REAL&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>scal,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>sc_mode,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>mode</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Apply the scaling array on the indicated part of the matrix</div></div><div class=CToolTip id="tt35"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Analyze(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote></div></div><div class=CToolTip id="tt36"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_Factorize(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Perform matrix factorization.</div></div><div class=CToolTip id="tt37"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ForceNoFacto(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Prevent Murge from running factorisation even if matrix has changed.</div></div><div class=CToolTip id="tt38"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ProductSetLocalNodeNbr (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameter  prettyprint " nowrap>n</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote></div></div><div class=CToolTip id="tt39"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_ProductSetLocalNodeList (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>l2g</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote></div></div><div class=CToolTip id="tt40"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalProduct (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>x</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Perform the product A * X.</div></div><div class=CToolTip id="tt41"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetGlobalProduct (</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>x,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Perform the product A * X.</div></div><div class=CToolTip id="tt42"><div class=CClass><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">struct pastix_data_t</td></tr></table></blockquote>Structure used to store datas for a step by step execution.</div></div><div class=CToolTip id="tt43"><div class=CClass>Structure used to store murge data</div></div><div class=CToolTip id="tt44"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_GetLocalUnknownNbr(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>unkownnbr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Computes preprocessing step, if not done, and the number of Unkowns in the new ditribution of the matrix.</div></div><div class=CToolTip id="tt45"><div class=CFunction>Computes preprocessing step, if not done, and the number of Unkowns in the new ditribution of the matrix.</div></div><div class=CToolTip id="tt46"><div class=CType>Operations possible when a coefficient appear twice.</div></div><div class=CToolTip id="tt47"><div class=CType>Indicates if user can ensure that the information he is giving respects the solver distribution.</div></div><div class=CToolTip id="tt48"><div class=CType>Flags for Murge&rsquo;s norm rules</div></div><div class=CToolTip id="tt49"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetLocalRHS(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>b,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op2</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Set the right-hand-side member in local mode.</div></div><div class=CToolTip id="tt50"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>INTS MURGE_SetGlobalRHS(</td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>id,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>COEF&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>b,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>root,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>INTS&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>op</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Set the right-hand-side member in global mode.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>