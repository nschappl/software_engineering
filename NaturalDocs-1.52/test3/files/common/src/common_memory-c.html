<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>common_memory.c</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script><script language=JavaScript src="../../../javascript/prettify.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad();prettyPrint();"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.52 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->




<div id=Content><div class="CFile"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="common_memory.c"></a>common_memory.c</h1><div class=CBody><p>Part of a parallel direct block solver.</p><p>This module handles errors.</p><h4 class=CHeading>Authors</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Mathieu Faverge</td><td class=CDLDescription><a href="#" onClick="location.href='mai' + 'lto:' + 'fav' + 'erge' + '@' + 'labr' + 'i.fr'; return false;" class=LEMail>fav<span style="display: none">.nosp@m.</span>erge<span>@</span>labr<span style="display: none">.nosp@m.</span>i.fr</a></td></tr><tr><td class=CDLEntry>Xavier   LACOSTE</td><td class=CDLDescription><a href="#" onClick="location.href='mai' + 'lto:' + 'lac' + 'oste' + '@' + 'labr' + 'i.fr'; return false;" class=LEMail>lac<span style="display: none">.nosp@m.</span>oste<span>@</span>labr<span style="display: none">.nosp@m.</span>i.fr</a></td></tr><tr><td class=CDLEntry>Francois PELLEGRINI</td><td class=CDLDescription>.</td></tr></table><h4 class=CHeading>Dates</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Version 0.0</td><td class=CDLDescription>from 07 sep 2001 to   07 sep 2001</td></tr><tr><td class=CDLEntry>Version 0.1</td><td class=CDLDescription>from 14 apr 2001 to   24 mar 2003</td></tr><tr><td class=CDLEntry>Version 1.3</td><td class=CDLDescription>from 25 feb 2004 to   25 feb 2004</td></tr></table><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SMain"><td class=SEntry><a href="#common_memory.c" >common_memory.c</a></td><td class=SDescription>Part of a parallel direct block solver.</td></tr><tr class="SGroup"><td class=SEntry><a href="#Variables" >Variables</a></td><td class=SDescription>The static variables.</td></tr><tr class="SVariable SIndent1 SMarked"><td class=SEntry><a href="#memallocmutexflag" >memallocmutexflag</a></td><td class=SDescription>Boolean indicating if &lt;memallocmutexdat&gt; mutex has been initialized.</td></tr><tr class="SVariable SIndent1"><td class=SEntry><a href="#memalloccurrent" >memalloccurrent</a></td><td class=SDescription>Current memory allocated using <a href="#memAlloc_func" class=LFunction id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">memAlloc_func</a>.</td></tr><tr class="SVariable SIndent1 SMarked"><td class=SEntry><a href="#memallocmax" >memallocmax</a></td><td class=SDescription>Maximum value of memalloccurrent since the program started.</td></tr><tr class="SVariable SIndent1"><td class=SEntry><a href="#memalloctraceflag" >memalloctraceflag</a></td><td class=SDescription>Boolean indicating if we want to trace allocation.</td></tr><tr class="SVariable SIndent1 SMarked"><td class=SEntry><a href="#time_stamp" >time_stamp</a></td><td class=SDescription>Origin of traces.</td></tr><tr class="SVariable SIndent1"><td class=SEntry><a href="#trace_procnum" >trace_procnum</a></td><td class=SDescription>Processor tracing allocations.</td></tr><tr class="SGroup"><td class=SEntry><a href="#Functions" >Functions</a></td><td class=SDescription>The memory handling routines.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#memAllocaTrace" >memAllocaTrace</a></td><td class=SDescription>Start tracing memory.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#memAllocUntrace" id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">memAllocUntrace</a></td><td class=SDescription>Stop tracing allocations.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#memAllocGetCurrent" id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">memAllocGetCurrent</a></td><td class=SDescription>Get the current memory allocated.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#memAllocGetMax" id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">memAllocGetMax</a></td><td class=SDescription>Get the maximu memory allocated.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#memAllocTraceReset" id=link5 onMouseOver="ShowTip(event, 'tt5', 'link5')" onMouseOut="HideTip('tt5')">memAllocTraceReset</a></td><td class=SDescription>Restarts tracing allocation with reseting <a href="#memallocmax" class=LVariable id=link6 onMouseOver="ShowTip(event, 'tt6', 'link6')" onMouseOut="HideTip('tt6')">memallocmax</a>.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#memAlloc_func" id=link7 onMouseOver="ShowTip(event, 'tt1', 'link7')" onMouseOut="HideTip('tt1')">memAlloc_func</a></td><td class=SDescription>This is a thread-safe memory allocation routine.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#memRealloc" id=link8 onMouseOver="ShowTip(event, 'tt7', 'link8')" onMouseOut="HideTip('tt7')">memRealloc</a></td><td class=SDescription>This is a thread-safe memory reallocation routine.</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#memFree" id=link9 onMouseOver="ShowTip(event, 'tt8', 'link9')" onMouseOut="HideTip('tt8')">memFree</a></td><td class=SDescription>This is a thread-safe memory deallocation routine.</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#memAllocGroup" id=link10 onMouseOver="ShowTip(event, 'tt9', 'link10')" onMouseOut="HideTip('tt9')">memAllocGroup</a></td><td class=SDescription>This routine allocates a set of arrays in a single memAlloc()&rsquo;ed array, the address of which is placed in the first argument. </td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#memAllocGroup" >memAllocGroup</a></td><td class=SDescription>This routine reallocates a set of arrays in a single memRealloc()&rsquo;ed array passed as first argument, and the address of which is placed in the second argument. </td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#memOffset" id=link11 onMouseOver="ShowTip(event, 'tt10', 'link11')" onMouseOut="HideTip('tt10')">memOffset</a></td><td class=SDescription>This routine computes the offsets of arrays of given sizes and types with respect to a given base address passed as first argument. </td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Variables"></a>Variables</h3><div class=CBody><p>The static variables.</p></div></div></div>

<div class="CVariable"><div class=CTopic><h3 class=CTitle><a name="memallocmutexflag"></a>memallocmutexflag</h3><div class=CBody><p>Boolean indicating if &lt;memallocmutexdat&gt; mutex has been initialized.</p><p>pthread_mutex_t: memallocmutexdat mutex protecting <a href="#memalloccurrent" class=LVariable id=link12 onMouseOver="ShowTip(event, 'tt11', 'link12')" onMouseOut="HideTip('tt11')">memalloccurrent</a>, <a href="#memallocmax" class=LVariable id=link13 onMouseOver="ShowTip(event, 'tt6', 'link13')" onMouseOut="HideTip('tt6')">memallocmax</a>, <a href="#memalloctraceflag" class=LVariable id=link14 onMouseOver="ShowTip(event, 'tt12', 'link14')" onMouseOut="HideTip('tt12')">memalloctraceflag</a>, &lt;trace_file&gt;, &lt;trace_timestamp&gt; and <a href="#trace_procnum" class=LVariable id=link15 onMouseOver="ShowTip(event, 'tt13', 'link15')" onMouseOut="HideTip('tt13')">trace_procnum</a></p></div></div></div>

<div class="CVariable"><div class=CTopic><h3 class=CTitle><a name="memalloccurrent"></a>memalloccurrent</h3><div class=CBody><p>Current memory allocated using <a href="#memAlloc_func" class=LFunction id=link16 onMouseOver="ShowTip(event, 'tt1', 'link16')" onMouseOut="HideTip('tt1')">memAlloc_func</a>.</p></div></div></div>

<div class="CVariable"><div class=CTopic><h3 class=CTitle><a name="memallocmax"></a>memallocmax</h3><div class=CBody><p>Maximum value of memalloccurrent since the program started.</p></div></div></div>

<div class="CVariable"><div class=CTopic><h3 class=CTitle><a name="memalloctraceflag"></a>memalloctraceflag</h3><div class=CBody><p>Boolean indicating if we want to trace allocation.</p><p>stream: trace_file File into which to write traces.</p></div></div></div>

<div class="CVariable"><div class=CTopic><h3 class=CTitle><a name="time_stamp"></a>time_stamp</h3><div class=CBody><p>Origin of traces.</p></div></div></div>

<div class="CVariable"><div class=CTopic><h3 class=CTitle><a name="trace_procnum"></a>trace_procnum</h3><div class=CBody><p>Processor tracing allocations.</p></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Functions"></a>Functions</h3><div class=CBody><p>The memory handling routines.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memAllocaTrace"></a>memAllocaTrace</h3><div class=CBody><p>Start tracing memory.</p><p>Initialize &lt;memallocmutexdat&gt; if not done.</p><p>Defines all tracing variables.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>file</td><td class=CDLDescription>Stream where to write traces, opened in write mode.</td></tr><tr><td class=CDLEntry>timestamp</td><td class=CDLDescription>Traces origin.</td></tr><tr><td class=CDLEntry>procnum</td><td class=CDLDescription>Processor writting traces.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>void</td><td class=CDLDescription>In all cases.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memAllocUntrace"></a>memAllocUntrace</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">void memAllocUntrace ()</td></tr></table></blockquote><p>Stop tracing allocations.</p><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>void</td><td class=CDLDescription>in all cases.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memAllocGetCurrent"></a>memAllocGetCurrent</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">unsigned long memAllocGetCurrent ()</td></tr></table></blockquote><p>Get the current memory allocated.</p><h4 class=CHeading>Returns</h4><p><a href="#memalloccurrent" class=LVariable id=link17 onMouseOver="ShowTip(event, 'tt11', 'link17')" onMouseOut="HideTip('tt11')">memalloccurrent</a> value.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memAllocGetMax"></a>memAllocGetMax</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">unsigned long memAllocGetMax ()</td></tr></table></blockquote><p>Get the maximu memory allocated.</p><h4 class=CHeading>Returns</h4><p><a href="#memallocmax" class=LVariable id=link18 onMouseOver="ShowTip(event, 'tt6', 'link18')" onMouseOut="HideTip('tt6')">memallocmax</a> value.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memAllocTraceReset"></a>memAllocTraceReset</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">void memAllocTraceReset ()</td></tr></table></blockquote><p>Restarts tracing allocation with reseting <a href="#memallocmax" class=LVariable id=link19 onMouseOver="ShowTip(event, 'tt6', 'link19')" onMouseOut="HideTip('tt6')">memallocmax</a>.</p><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>void</td><td class=CDLDescription>in all cases.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memAlloc_func"></a>memAlloc_func</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>void * memAlloc_func (</td><td class="PType  prettyprint " nowrap>size_t&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>size,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>filename,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>int&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>line</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>This is a thread-safe memory allocation routine.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>size</td><td class=CDLDescription>Memory size wanted.</td></tr><tr><td class=CDLEntry>filename</td><td class=CDLDescription>Used for error message, file where the function is called.</td></tr><tr><td class=CDLEntry>line</td><td class=CDLDescription>Used for erro message, line where the function is called.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>!NULL</td><td class=CDLDescription>pointer to memory block.</td></tr><tr><td class=CDLEntry>NULL</td><td class=CDLDescription>no array allocated.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memRealloc"></a>memRealloc</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>void * memRealloc_func (</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>memptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>size_t&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>size,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>filename,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>int&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>line</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>This is a thread-safe memory reallocation routine.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>memptr</td><td class=CDLDescription>address of the array to realloc.</td></tr><tr><td class=CDLEntry>size</td><td class=CDLDescription>New size wanted.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>!NULL</td><td class=CDLDescription>pointer to memory block.</td></tr><tr><td class=CDLEntry>NULL</td><td class=CDLDescription>no array allocated.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memFree"></a>memFree</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>void memFree (</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>memptr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>This is a thread-safe memory deallocation routine.</p><h4 class=CHeading>It returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>void</td><td class=CDLDescription>in all cases</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memAllocGroup"></a>memAllocGroup</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>void * memAllocGroup (</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>**</td><td class="PParameter  prettyprint " nowrap>memptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>...</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>This routine allocates a set of arrays in a single memAlloc()&rsquo;ed array, the address of which is placed in the first argument.&nbsp; Arrays to be allocated are described as a duplet of ..., &amp;ptr, size, ..., terminated by a NULL pointer.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>memptr</td><td class=CDLDescription>Pointer to first argument to allocate</td></tr><tr><td class=CDLEntry>...</td><td class=CDLDescription>list of duplets &amp;ptr, size, starting by size and ending by size.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>!NULL</td><td class=CDLDescription>pointer to block, all arrays allocated.</td></tr><tr><td class=CDLEntry>NULL</td><td class=CDLDescription>no array allocated.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memAllocGroup"></a>memAllocGroup</h3><div class=CBody><p>This routine reallocates a set of arrays in a single memRealloc()&rsquo;ed array passed as first argument, and the address of which is placed in the second argument.&nbsp; Arrays to be allocated are described as a duplet of ..., &amp;ptr, size, ..., terminated by a NULL pointer.&nbsp; WARNING: Because of memory alignment issues between int and double values, when arrays are not reallocated in place, offsets of arrays may vary, so that one should rather compute differences with respect to original offsets than rely on offsets returned by the routine.&nbsp; This routine should be used with extreme caution!</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>oldptr</td><td class=CDLDescription>Pointer to first block to reallocate.</td></tr><tr><td class=CDLEntry>...</td><td class=CDLDescription>list of duplets &amp;ptr, size, starting by size and ending by size.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>!NULL</td><td class=CDLDescription>pointer to block, all arrays allocated.</td></tr><tr><td class=CDLEntry>NULL</td><td class=CDLDescription>no array allocated.</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="memOffset"></a>memOffset</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>void * memOffset (</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>memptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>...</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>This routine computes the offsets of arrays of given sizes and types with respect to a given base address passed as first argument.&nbsp; Arrays the offsets of which are to be computed are described as a duplet of ..., &amp;ptr, size, ..., terminated by a NULL pointer.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>memptr</td><td class=CDLDescription>Pointer to base address of memory area.</td></tr><tr><td class=CDLEntry>...</td><td class=CDLDescription>list of duplets &amp;ptr, size, starting by size and ending by size.</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>!NULL</td><td class=CDLDescription>in all cases, pointer to the end of the memory area.</td></tr></table></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>void * memAlloc_func (</td><td class="PType  prettyprint " nowrap>size_t&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>size,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>filename,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>int&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>line</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>This is a thread-safe memory allocation routine.</div></div><div class=CToolTip id="tt2"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">void memAllocUntrace ()</td></tr></table></blockquote>Stop tracing allocations.</div></div><div class=CToolTip id="tt3"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">unsigned long memAllocGetCurrent ()</td></tr></table></blockquote>Get the current memory allocated.</div></div><div class=CToolTip id="tt4"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">unsigned long memAllocGetMax ()</td></tr></table></blockquote>Get the maximu memory allocated.</div></div><div class=CToolTip id="tt5"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td class="prettyprint">void memAllocTraceReset ()</td></tr></table></blockquote>Restarts tracing allocation with reseting memallocmax.</div></div><div class=CToolTip id="tt6"><div class=CVariable>Maximum value of memalloccurrent since the program started.</div></div><div class=CToolTip id="tt7"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>void * memRealloc_func (</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>memptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>size_t&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>size,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>char&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>filename,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>int&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>line</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>This is a thread-safe memory reallocation routine.</div></div><div class=CToolTip id="tt8"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>void memFree (</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>memptr</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>This is a thread-safe memory deallocation routine.</div></div><div class=CToolTip id="tt9"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>void * memAllocGroup (</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>**</td><td class="PParameter  prettyprint " nowrap>memptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>...</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>This routine allocates a set of arrays in a single memAlloc()&rsquo;ed array, the address of which is placed in the first argument. </div></div><div class=CToolTip id="tt10"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>void * memOffset (</td><td class="PType  prettyprint " nowrap>void&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>memptr,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>...</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>This routine computes the offsets of arrays of given sizes and types with respect to a given base address passed as first argument. </div></div><div class=CToolTip id="tt11"><div class=CVariable>Current memory allocated using memAlloc_func.</div></div><div class=CToolTip id="tt12"><div class=CVariable>Boolean indicating if we want to trace allocation.</div></div><div class=CToolTip id="tt13"><div class=CVariable>Processor tracing allocations.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>