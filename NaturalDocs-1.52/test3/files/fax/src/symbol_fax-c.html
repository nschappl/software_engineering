<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>symbol_fax.c</title><link rel="stylesheet" type="text/css" href="../../../styles/main.css"><script language=JavaScript src="../../../javascript/main.js"></script><script language=JavaScript src="../../../javascript/prettify.js"></script></head><body class="FramedContentPage" onLoad="NDOnLoad();prettyPrint();"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.52 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->




<div id=Content><div class="CFile"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="symbol_fax.c"></a>symbol_fax.c</h1><div class=CBody><p>Part of a parallel direct block solver.&nbsp; This is the generic block symbolic factorization routine.</p><h4 class=CHeading>Authors</h4><ul><li>Francois Pellegrini</li><li>Jean Roman (v0.0)</li></ul><h4 class=CHeading>Dates</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>Version 0.0</td><td class=CDLDescription>from 22 jul 1998 to 29 sep 1998</td></tr><tr><td class=CDLEntry>Version 0.1</td><td class=CDLDescription>from 04 apr 1999 to 21 apr 1999</td></tr><tr><td class=CDLEntry>Version 0.2</td><td class=CDLDescription>from 08 may 2000 to 09 may 2000</td></tr><tr><td class=CDLEntry>Version 1.0</td><td class=CDLDescription>from 13 mar 2002 to 08 jun 2002</td></tr><tr><td class=CDLEntry>Version 1.2</td><td class=CDLDescription>from 23 aug 2002 to 23 aug 2002</td></tr><tr><td class=CDLEntry>Version 2.0</td><td class=CDLDescription>from 21 mar 2003 to 21 mar 2003</td></tr></table><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SMain"><td class=SEntry><a href="#symbol_fax.c" >symbol_fax.c</a></td><td class=SDescription>Part of a parallel direct block solver. </td></tr><tr class="SGroup"><td class=SEntry><a href="#Macros" >Macros</a></td><td class=SDescription></td></tr><tr class="SMacro SIndent1 SMarked"><td class=SEntry><a href="#SYMBOL_FAX_ITERATOR" >SYMBOL_FAX_ITERATOR</a></td><td class=SDescription>Loop for all adjacent edges, used in <a href="symbol_faxi-c.html#symbolFaxi" class=LFunction id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">symbolFaxi</a>. </td></tr><tr class="SMacro SIndent1"><td class=SEntry><a href="#SYMBOL_FAX_VERTEX_DEGREE" >SYMBOL_FAX_VERTEX_DEGREE</a></td><td class=SDescription>Computes the number of adjacent edges to a vertex.</td></tr><tr class="SGroup"><td class=SEntry><a href="#Functions" >Functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#symbolFax" id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">symbolFax</a></td><td class=SDescription>Symbolic factorization routine.</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Macros"></a>Macros</h3></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="SYMBOL_FAX_ITERATOR"></a>SYMBOL_FAX_ITERATOR</h3><div class=CBody><p>Loop for all adjacent edges, used in <a href="symbol_faxi-c.html#symbolFaxi" class=LFunction id=link3 onMouseOver="ShowTip(event, 'tt1', 'link3')" onMouseOut="HideTip('tt1')">symbolFaxi</a>.&nbsp; Must be defined in including file if SYMBOL_FAXI_INCLUDED is defined.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>ngbdptr</td><td class=CDLDescription>Neighbour pointer.</td></tr><tr><td class=CDLEntry>vertnum</td><td class=CDLDescription>Vertex index.</td></tr><tr><td class=CDLEntry>vertend</td><td class=CDLDescription>Iterator.</td></tr></table></div></div></div>

<div class="CMacro"><div class=CTopic><h3 class=CTitle><a name="SYMBOL_FAX_VERTEX_DEGREE"></a>SYMBOL_FAX_VERTEX_DEGREE</h3><div class=CBody><p>Computes the number of adjacent edges to a vertex.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>ngbdptr</td><td class=CDLDescription>Neighbour pointer.</td></tr><tr><td class=CDLEntry>vertnum</td><td class=CDLDescription>Vertex index.</td></tr></table></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="Functions"></a>Functions</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="symbolFax"></a>symbolFax</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "colspan=4>int symbolFax (</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>SymbolMatrix *&nbsp;</td><td class="PType  prettyprint " nowrap>const&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>symbptr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>INT&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>vertnbr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>INT&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>edgenbr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>INT&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>baseval,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>void *&nbsp;</td><td class="PType  prettyprint " nowrap>const&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>ngbdptr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>INT&nbsp;</td><td class="PType  prettyprint " nowrap>ngbfrst&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>(void * const, const INT),</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>INT&nbsp;</td><td class="PType  prettyprint " nowrap>ngbnext&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>(void * const),</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>INT&nbsp;</td><td class="PType  prettyprint " nowrap>ngbdegr&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>(void * const, const INT),</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const Order *&nbsp;</td><td class="PType  prettyprint " nowrap>const&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>ordeptr</td></tr><tr><td class="PAfterParameters  prettyprint "colspan=4>) #endif /* SYMBOL_FAX_INCLUDED */</td></tr></table></td></tr></table></blockquote><p>Symbolic factorization routine.</p><p>This routine computes the block symbolic factorization of the given matrix according to the given vertex ordering.</p><h4 class=CHeading>Algorithm</h4><p>The algorithm is implemented in a cache-friendly manner, by using a single dynamic array which grows along with the number of computed blocks.&nbsp; The array is decomposed in the following manner:</p><ul><li>In a first phase, a hash table and a sort area are reserved at the end of the space of already computed blocks.&nbsp; The sort area is created far enough from the end of the array of already computed blocks such that if there are no contributing blocks all new blocks can be created without colliding with the sort area.</li><li>Then, in a second phase, if the current column block does have contributing column blocks, an area for simply-linked temporary blocks is reserved at least after the sort area, leaving enough space to create all of the corresponding potential new blocks just after all the blocks of the previous column block (right picture).</li></ul><blockquote><pre>|ccccccccccc| &lt;- bloktab (bloktax)
|ccccccccccc|
|ccccccccccc|                                :ccccccccccc:
|ccccccccccc| &gt;- Computed blocks ----------&lt; |ccccccccccc|
|ccccccccccc|                                |ccccccccccc|
|-----------|                                |:::::::::::|
|hhhhhhhhhhh| &lt;- hashtab = bloknum --------&gt; |bcbcbcbcbcb|
|hhhhhhhhhhh|                 |              |cbcbcbcbcbc|
|hhhhhhhhhhh|                 |              |bcbcbcbcbcb|
|hhhhhhhhhhh|                 |              |cbcbcbcbcbc|
|-----------|                 |              |bcbcbcbcbcb|
|           |                 |              |-----------|
|-----------| &lt;- sorttab...... ------------&gt; |           |
|sssssssssss|                                |           |
|sssssssssss|                                |           |
|-----------| &lt;- ............................|           |
|           |                     tloktab -&gt; |-----------|
|           |                                |ttttttttttt|
|           |                                |ttttttttttt|
:           :                                |-----------|
:___________:                                :___________:
              &lt;- bloktab + blokmax</pre></blockquote><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>symbptr</td><td class=CDLDescription>Symbolic block matrix [based]</td></tr><tr><td class=CDLEntry>vertnbr</td><td class=CDLDescription>Number of vertices</td></tr><tr><td class=CDLEntry>edgenbr</td><td class=CDLDescription>Number of edges</td></tr><tr><td class=CDLEntry>baseval</td><td class=CDLDescription>Base value</td></tr><tr><td class=CDLEntry>ngbdptr</td><td class=CDLDescription>Neighbor bookkeeping area</td></tr><tr><td class=CDLEntry>ngbfrst</td><td class=CDLDescription>First neighbor function</td></tr><tr><td class=CDLEntry>ngbnext</td><td class=CDLDescription>Next neighbor function</td></tr><tr><td class=CDLEntry>ngbdegr</td><td class=CDLDescription>Vertex degree function (upper bound)</td></tr><tr><td class=CDLEntry>ordeptr</td><td class=CDLDescription>Matrix ordering</td></tr></table><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>0</td><td class=CDLDescription>on success.</td></tr><tr><td class=CDLEntry>!0</td><td class=CDLDescription>on error.</td></tr></table></div></div></div>

</div><!--Content-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "colspan=4>int symbolFaxi (</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>SymbolMatrix *&nbsp;</td><td class="PType  prettyprint " nowrap>const&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>symbptr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>INT&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>vertnbr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>INT&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>edgenbr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>INT&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>baseval,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>void *&nbsp;</td><td class="PType  prettyprint " nowrap>const&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>ngbdptr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>INT&nbsp;</td><td class="PType  prettyprint " nowrap>ngbfrst&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>(void * const, const INT),</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>INT&nbsp;</td><td class="PType  prettyprint " nowrap>ngbnext&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>(void * const),</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>INT&nbsp;</td><td class="PType  prettyprint " nowrap>ngbdegr&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>(void * const, const INT),</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const Order *&nbsp;</td><td class="PType  prettyprint " nowrap>const&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>ordeptr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>INT&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>levfmax</td></tr><tr><td class="PAfterParameters  prettyprint "colspan=4>) #endif /* SYMBOL_FAXI_INCLUDED */</td></tr></table></td></tr></table></blockquote>Incomplete symbolic factorization routine with limitation of level-of-fill value.</div></div><div class=CToolTip id="tt2"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "colspan=4>int symbolFax (</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>SymbolMatrix *&nbsp;</td><td class="PType  prettyprint " nowrap>const&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>symbptr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>INT&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>vertnbr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>INT&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>edgenbr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const&nbsp;</td><td class="PType  prettyprint " nowrap>INT&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>baseval,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>void *&nbsp;</td><td class="PType  prettyprint " nowrap>const&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>ngbdptr,</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>INT&nbsp;</td><td class="PType  prettyprint " nowrap>ngbfrst&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>(void * const, const INT),</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>INT&nbsp;</td><td class="PType  prettyprint " nowrap>ngbnext&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>(void * const),</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>INT&nbsp;</td><td class="PType  prettyprint " nowrap>ngbdegr&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>(void * const, const INT),</td></tr><tr><td>&nbsp;&nbsp;&nbsp;</td><td class="PTypePrefix  prettyprint " nowrap>const Order *&nbsp;</td><td class="PType  prettyprint " nowrap>const&nbsp;</td><td class="PParameter  prettyprint " nowrap width=100%>ordeptr</td></tr><tr><td class="PAfterParameters  prettyprint "colspan=4>) #endif /* SYMBOL_FAX_INCLUDED */</td></tr></table></td></tr></table></blockquote>Symbolic factorization routine.</div></div><!--END_ND_TOOLTIPS-->

<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>